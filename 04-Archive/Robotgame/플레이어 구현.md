---
tags:
  - Unity
  - Project
---

## 전체 구조

![[Exacli-RobotgamePlayer]]

## 플레이어 이동 - PlayerMove.cs

2023-12-23
플레이어 이동은 우선 할로우 나이트의 움직임을 레퍼런스로 해 구현한다. 이를 구현하기 위해 가장 필요한 것은 **반동 없는 움직임과 일정한 점프 속도**라고 생각했으므로, 인풋을 조정하고 점프(+이단 점프)를 구현하는 방향으로 진행한다. 아래는 전체 코드.

```cpp
public class PlayerMove : MonoBehaviour
{

    public PlayerStateList pState;
    
    // Vertical Movement Parameters
    [SerializeField] float walkSpeed = 5.0f;
    [SerializeField] float minSpeed = 0.2f;
    
    // Horizontal Movement Parameters
    [SerializeField] float jumpSpeed = 50;
    [SerializeField] float gravity = 9.8f;
    [SerializeField] int maxJump = 50;
    public float jumpCount;
    [SerializeField] bool jumpDone = false;
    
    // Inputs
    public float xInput;
    public float yInput;
    
    // Components
    private Rigidbody2D rb;
    private BoxCollider2D playerCol;
    private SpriteRenderer render;
    
    // Apply knockback
    private PlayerKnockback playerKnockback;
    
    // [SerializedField] Animator anim;
    
    void Awake()
    {
        if (pState == null)
        {
            pState = GetComponent<PlayerStateList>();
        }
        
        rb = GetComponent<Rigidbody2D>();
        playerCol = GetComponent<BoxCollider2D>();
        render = GetComponent<SpriteRenderer>();
        playerKnockback = GetComponent<PlayerKnockback>();
    }

    void Update()
    {
        AdjustInput();
        
        // 넉백 중에는 점프 영향 x
        if (!playerKnockback.isKnockback)
        {
            Jump();
        }
    }

    void FixedUpdate()
    {
        Flip();

        if (!playerKnockback.isKnockback)
        {
           Walk(xInput); 
        }
        
        
        // Set the falling speed within a specified range
        if (rb.velocity.y <= 0)
        {
            rb.velocity = new Vector2(rb.velocity.x, rb.velocity.y - gravity * Time.deltaTime);
        }
    }

    void AdjustInput()
    {
        // Adjust Input to ignore input sensitivity
        xInput = Input.GetAxis("Horizontal");
        yInput = Input.GetAxis("Vertical");

        if (xInput < -minSpeed)
        {
            xInput = -1;
        }
        else if (xInput > minSpeed)
        {
            xInput = 1;
        }
        else
        {
            xInput = 0;
        }

        if (yInput < -minSpeed)
        {
            yInput = -1;
        }
        else if (yInput > minSpeed)
        {
            yInput = 1;
        }
        else 
        {
            yInput = 0;
        }
    }

    void Walk(float xInput)
    {
        // 걷기 & 걷기 상태 설정
        rb.velocity = new Vector2(xInput * walkSpeed, rb.velocity.y);
        if (Grounded() && Mathf.Abs(xInput) > 0.2f)
        {
            pState.isWalking = true;
        }
        else
        {
            pState.isWalking = false;
        }
    }
    
    void Jump()
    {
        // 순서대로 점프 & 이단 점프 조건
        if (Input.GetButtonDown("Jump") && Grounded() && !jumpDone)
        {
            pState.isJumping = true;
        }
        else if (Input.GetButtonDown("Jump") && !Grounded() && !jumpDone)
        {
            pState.isJumping = true;
            jumpDone = true;
        }
    
        // 일단 뛰고 있는 중이면 상승, 일정 높이 도달시 점프 중지
        if (pState.isJumping)
        {
            if (jumpCount < maxJump)
            {
                rb.velocity = new Vector2(rb.velocity.x, jumpSpeed);
                jumpCount++;
            }
            else
            {
                StopJump();
            }
        }
        
        // 키를 떼면 바로 추락
        if (!Input.GetButton("Jump") && pState.isJumping)
        {
            StopJump();
        }
        
        // 땅에 도달시에 점프 횟수 초기화
        if (Grounded())
        {
            jumpDone = false;
        }
    }

    // Cancel the jump quickly when there is no input
    void StopJump()
    {
        jumpCount = 0;
        rb.velocity = new Vector2(rb.velocity.x, 0);
        pState.isJumping = false;
    }

    // Check if the player is on the ground of roofed
    public bool Grounded()
    {
        
        RaycastHit2D raycastHit = Physics2D.BoxCast(playerCol.bounds.center, playerCol.bounds.size,
            0f, Vector2.down, 0.02f, LayerMask.GetMask("Ground"));
        if ((raycastHit.collider != null) && !pState.isJumping)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    // Flip the player's movement direction based on the input
    void Flip()
    {
        if (xInput < 0)
        {
            render.flipX = true;
        }
        else if (xInput > 0)
        {
            render.flipX = false;
        }
    }
}
```

### AdjustInput()
- x축과 y축 방향의 인풋을 조정한다
- 조금만 눌러도 1이 되도록 조정. -> 반동이 없는 움직임 구현

### Walk(float xInput)
- x축 방향 인풋을 받아 속도 조정
- 걷기 상태 업데이트 (추후 애니메이션을 위함)

### Jump()
- 적당히 이단 점프 구현
- 다만 인풋을 이용해 점프 속도를 조절하는 것이 아닌, 인풋에 따른 *isJumping* 변수의 변화에 따라 속도를 조정함에 유의
- 이단 점프는 *jumpDone* 변수를 이용해 판단.
- 인풋이 없다면 아래의 StopJump()를 실행해 점프를 멈춘다

### StopJump()
- 인풋이 없을 때 점프를 멈추는 역할
- 단독으로는 속도 조정만 하고, 인풋이 없음을 판단하는 것은 *Jump()* 함수에서 이루어짐.

### Grounded() 
- 플레이어가 땅에 붙어있는지를 bool로 반환
- BoxCast를 이용해 판단하는 방식

### Flip()
- 플레이어의 방향 조정
- 플레이어의 속도를 이용해 판단하는 방식
## 플레이어 절전 - PlayerPowerSaving

배터리 기능을 만들면서 보니 *가만히 있을 때*는 배터리 소모가 없음
	-> 당위성이 없지 않나? -> 절전 기능을 만들면 되겠구나!
일정 시간 가만히 있으면 주인공이 절전 기능을 시행, 배터리 소모를 없앰.
기능 구현은 쉬우나, 이를 보충할 애니메이션이 가장 중요

## 플레이어 공격  - PlayerCombat.cs

~~초기 버전은 플레이어의 공격도 *OverlapBoxAll 방식을 이용했고*, 넉백 또한 *몬스터와 플레이어의 rigidbody를 불러와 힘을 추가한 뒤 이동 스크립트를 정지하는 방식*을 이용했으나, 놀랍도록 비효율적이길래 전부 뜯어 고쳤다. 애초에 몬스터의 스크립트를 모두 불러와 비활성화한다는 방법은 말이 안되긴 했다~~

아래는 전체코드.
```cpp
public class PlayerCombat : MonoBehaviour
{
    public PlayerStateList pState;
    private SpriteRenderer render;
    private PlayerKnockback playerKnockback;
    private PlayerMove playerMove;
    
    public float coolTime = 0.5f;
    private float curTime = 0;

    [Header("Attack")]
    public GameObject normalAtkObject;
    public float atkRange = 1.5f;
    [SerializeField] private bool isUnbeatTime = false;
    
    // Start is called before the first frame update
    void Awake()
    {
        pState = GetComponent<PlayerStateList>();
        render = GetComponent<SpriteRenderer>();
        playerMove = GetComponent<PlayerMove>();
        playerKnockback = GetComponent<PlayerKnockback>();
    }

    // Update is called once per frame
    void Update()
    {
        Attack();
    }

    public void Attack()
    {
        if (curTime <= 0)
        {
            if (Input.GetKey(KeyCode.Z))
            {
                Vector2 atkPosition = Vector2.zero;
                pState.isAttacking = true;
                
                if (render.flipX)
                {
                    atkPosition = transform.position + Vector3.left * atkRange / 2;
                }
                else
                {
                    atkPosition = transform.position + Vector3.right * atkRange / 2;
                }

                GameObject atk = Instantiate(normalAtkObject, atkPosition, transform.rotation);
                atk.transform.SetParent(transform);
                
                curTime = coolTime;
            }
        }
        else
        {
            curTime -= Time.deltaTime;
            pState.isAttacking = false;
        }
    }
    
    private void OnCollisionEnter2D(Collision2D other)
    {
        // 적과 충돌시에 넉백 적용 + 체력 감소 + 무적시간 적용
        if (other.gameObject.CompareTag("Enemy") && !isUnbeatTime)
        {
            Rigidbody2D enemyRb = other.gameObject.GetComponent<Rigidbody2D>();
            enemyRb.velocity = Vector2.zero;
            
            isUnbeatTime = true;
            TakeDamage(other.gameObject.transform, 1);
        }
    }

    public void TakeDamage(Transform other, int damage)
    {
        Vector2 hitDirection;
        
        // 체력 감소
        GameManager.Instance.health -= damage;
    
        // 플레이어에게 넉백 적용
        if (render.flipX)
        {
            hitDirection = Vector2.right;
        }
        else
        {
            hitDirection = Vector2.left;
        }
        
        playerKnockback.CallKnockback(hitDirection, Vector2.up, playerMove.xInput);
        StartCoroutine(UnBeatTime());
    }
    
    IEnumerator UnBeatTime()
    {
        // 무적시간 적용
        int countTime = 0;
        
        // 무적시간 초반 (0.4초) 에는 조작불가, 후반에는 조작 가능
        while (countTime < 5)
        {
            render.color = new Color32(255, 255, 255, 180);
            gameObject.layer = 11;
            yield return new WaitForSeconds(0.2f);
            countTime++;
        }

        gameObject.layer = 10;
        render.color = new Color32(255, 255, 255, 255);
        isUnbeatTime = false;

        yield return null;
    }
}
```

로직은 다음과 같다.
- **플레이어 공격** : Z 버튼을 누를 시 *공격 오브젝트를 소환하여* 공격한다. [[Prefab 모음|공격 오브젝트]]는 1초 뒤에 사라지며, 몬스터와 충돌시 몬스터에게 대미지와 넉백을 가한다.

사용 함수는 다음과 같다.
### Attack()
위처럼 z버튼을 감지, 공격 오브젝트를 플레이어 앞에 소환한다.

## 플레이어 피격 - PlayerCombat.cs, PlayerKnockback.cs

플레이어가 피격 당할시 고려해야할 사항 
- 플레이어에게 가해지는 대미지
- 플레이어에게 가해지는 넉백
대미지를 커스텀하려면 당연히 *공격마다*설정하는 게 좋기 때문에 공격 담당 오브젝트에서 `TakeDamage()` 메서드를 불러오는게 낫다.
마찬가지로 플레이어 넉백, 몬스터의 넉백 모두 부딪혔을때 상대의 넉백을 호출하는 방식으로 해결.

결론
- 플레이어 전투 스크립트에서 플레이어의 기본공격, 플레이어 대미지 함수를 집어넣고, 넉백 스크립트로 따로 작성, 무적 스크립트 또한 따로 작성 (훗날 무적 기능 고려)
- 대미지 -> 넉백 + 무적 흐름으로 실행되게 변경, 외부 몬스터 공격 오브젝트에서 플레이어의 대미지 함수를 불러오는 방식으로 해결!
- [?] 넉백과 무적을 동시에 구현해야할까? 무적과 대미지를 따로 처리해야할 상황이 온다면? -> ~~그 때 가서 생각하기~~ 아마도 대미지 함수에 bool 변수를 하나 더 넣은 뒤에 따로따로 처리하는 게 나을 듯 하다 -> 그러면 대미지를 입을 때마다 참조를 해야하는데 괜찮은가?

넉백은 [다음 링크 참조](https://www.youtube.com/watch?v=Jy1yXbKYW68)해 만들었으며, [[몬스터 구현]]의 넉백 부분도 이와 같은 방식으로 구현했다.

아래는 넉백의 전체 코드, PlayerComba.cs는 위를 참고.
```cpp
public class PlayerKnockback : MonoBehaviour
{
    public float knockbackTime = 0.2f;
    public float hitDirectionForce = 10f;
    public float constForce = 5f;
    public float inputForce = 7.5f;

    private Rigidbody2D rb;
    private Coroutine knockbackCoroutine;

    public bool isKnockback;

    private void Start()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    // 순서대로 (상대에 의해 밀리는 방향, 고정적으로 밀리는 방향, 인풋)을 넣으면 알아서 밀려남
    public IEnumerator KnockBackAction(Vector2 hitDirection, Vector2 constForceDirection, float inputDirection)
    {
        isKnockback = true;

        Vector2 _hitForce;
        Vector2 _constForce;
        Vector2 _knockbackForce;
        Vector2 _combinedForce;

        _hitForce = hitDirection * hitDirectionForce;
        _constForce = constForceDirection * constForce;
    
        // 타이머 생성
        float count = 0f;
        while (count < knockbackTime)
        {
            count += Time.deltaTime;
            _knockbackForce = _hitForce + _constForce;

            // 넉백 힘 + 인풋으로 인한 이동
            if (inputDirection != 0)
            {
                _combinedForce = _knockbackForce + new Vector2(inputDirection, 0f);
            }
            else
            {
                _combinedForce = _knockbackForce;
            }
            
            // 넉백 적용
            rb.velocity = _combinedForce;

            yield return new WaitForFixedUpdate();
        }

        rb.velocity = Vector2.zero;
        isKnockback = false;
    }

    public void CallKnockback(Vector2 hitDirection, Vector2 constForceDirection, float inputDirection)
    {
        knockbackCoroutine = StartCoroutine(KnockBackAction(hitDirection, constForceDirection, inputDirection));
    }
}
```

로직은 다음과 같다.
1. 플레이어의 피격은 *OnCollisionEnter2D*를 이용해 판단한다. 몬스터와 피격시 *대미지 함수* 발동!
2. 대미지 함수 발동시 플레이어의 체력을 줄이고, *넉백 함수와 무적 함수* 발동!
3. 넉백 함수에서는 피격 방향과 인풋을 받아 총 속도를 조절하는 방식으로 넉백을 적용.
4. 무적 함수는 코루틴을 이용해 일정 시간 동안 플레이어의 레이어를 바꾸는 방식으로 무적을 적용.

사용 함수는 다음과 같다. OnCollisionEnter2D는 생략했다. 아래는 *PlayerCombat.cs*.
### TakeDamage(Transform other, int damage) 
- 피격 대상의 위치와 대미지를 받아 플레이어에게 넉백과 대미지를 준다
- 마지막에 *CallKnockback과 UnBeatTime* 발동.
### IEnumerator UnBeatTime() 
- 무적 시간을 주는 코루틴, 플레이어의 레이어를 변화시켜 무적시간을 준다
- 무적 시간 동안 플레이어의 알파값이 변화.

아래는 *PlayerKnockback.cs*.
### IEnumerator KnockBackAction(Vector2 hitDirection, Vector2 constForceDirection, float inputDirection)
- 순서대로 피격방향, 고정 피격 방향(정해져있음), 현재 인풋을 받아 속도를 총합하여 업데이트해준다.
- PlayerMove.cs 스크립트에서 넉백 정보를 가져와 움직임을 업데이트 하기 때문에 충돌하지 않는다! 
- 내부에서는 벡터 연산을 한 뒤 최종적으로 속도를 결정한다.
### CallKnockback(Vector2 hitDirection, Vector2 constForceDirection, float inputDirection)
- 위의 넉백 코루틴을 다른 스크립트에서 불러오기 위해 사용하는 함수이다
- 외부 공격 오브젝트에서 주로 불러와 사용할 예정