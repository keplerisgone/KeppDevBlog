
아정리해야하는데 자료가 넘 많앙

## 디자인 패턴이란?

- 특정한 프로그램의 구현 방법이 아닌, 어떤 방식으로 프로그램을 구성할 것인지 정리한 **해결책, 구조, 아이디어**.
- 주로 소프트웨어 개발 과정에서 재사용 가능한 설계와 코드를 작성하는 데 도움을 준다.
- 알고리즘과는 다르다.
	- 알고리즘은 수학 문제의 정확한 풀이법과 같다면, 디자인 패턴은 풀이 방법에 가깝다.

![|625](https://i.imgur.com/CnD7DTh.png)

- **GoF (Gang of Five)** : 디자인 패턴에 대한 바이블. 한 번씩 읽는 것을 추천한다.
- 디자인 패턴을 배우는 이유
	- 다양한 프로그래밍 문제의 해결책이 될 수 있음.
	- 다른 프로그래머와의 의사소통을 위해 필요함.
	- 코드 작성을 위한 모범적인 기틀을 제공한다.

> [!warning]
> - 이를 문자 그대로 적용하면 그냥 코더가 된다!
> 	- 디자인 패턴의 탄생 당시는 최신 기술이 없었기 때문에 지금 기준에서는 비효율적일 수도 있다.
> - 따라서 무작정 따라하는 것이 아닌 체화를 시켜야하는 부분이다.

## 프로그래밍 패러다임

- 프로그래밍 언어의 특징과 스타일을 정의하는 개념
- 다만 프로그래밍 언어와는 구분되는 개념이므로, 프로그램을 보는 방법으로 보는 것이 옳다.
	- 예를 들어 절차적 프로그래밍이 중심인 C에서도 객체 지향 스타일을 만들 수 있다.
	- [요 링크](https://velog.io/@gomjellie/C%EC%9D%98-%EA%B0%9D%EC%B2%B4)가 잘 설명해주는 듯? `struct` 를 이용하면 된다고 한다.
- 다양한 프로그래밍 패러다임은 다음을 참고하자.

- 명령형 프로그래밍
	- [[절차적 프로그래밍]]
	- [[객체 지향 프로그래밍]]
- 선언형 프로그래밍
	- [[함수형 프로그래밍]]
	- [[논리형 프로그래밍]]

## SOLID 원칙

객체 지향에서 사용하는 설계 원칙으로, 소프트웨어 개발에서 유지보수성과 확장성을 높이기 위해 사용된다.
**단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙**으로 이루어져 있다.

### 단일 책임 원칙 (Single Responsibility Principle, SRP)

- 하나의 클래스는 하나의 기능이나 역할을 담당해야 한다.
- 코드의 가독성, 확장성, 재사용성, 유지보수성을 얻기 위한 원칙이다.

![|550](https://i.imgur.com/xR7twM7.png)

![|525](https://i.imgur.com/pMibGWg.png)

분명히 위보단 아래가 관리하기 쉽겠지...

### 개방-폐쇄 원칙 (Open/Closed Principle, OCP)

- 새로운 기능을 추가할 때 기존 코드를 수정하는 것보다 확장시키는 것이 우선되어야 한다.
- 이러러면 처음부터 코드 설계를 잘 해야한다.
- 인터페이스와 추상 클래스(abstract class)를 이용해 잘 설계한다.

![|600](https://i.imgur.com/t3VclpQ.png)

이렇게 설계하면 새로운 도형을 만들 때마다 새로운 도형 클래스를 만들고 `AreaCalculator` 클래스에도 새로운 메서드를 추가해야 한다.

![|600](https://i.imgur.com/irZg6w4.png)

이렇게 수정해 설계하면 `Shape`를 상속받는 클래스를 하나 만들고 그 안에 넓이 계산 메서드 `CalculateArea()`를 재정의하면 된다. 원래 코드를 수정할 필요가 없다!

### 리스코프 치환 원칙 (LisKov Substitution Principle, LSP)

- 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.
- 부모의 기능을 존중해야 한다.
- 부모에서 되던걸 자식에서 안 되게 하거나, 부모에서 안 되는걸 자식에서 되게 하면 안 된다.
- 이는 인터페이스를 활용해 *Polymorphism*을 이루어 달성할 수 있다.
	- 인터페이스로 기능을 나누어 사용하면 쉽다?

![](https://i.imgur.com/HRwAvoZ.png)

`Vehicle`에 모든 기능을 몰아서 구현하려고 하면, 돌 수 없는 `Train` 클래스에 `TurnRight(), TurnLeft()` 메서드가 불필요하게 존재한다.

![](https://i.imgur.com/pb94SZK.png)

 별도의 인터페이스를 만들어 기능을 구현하면 문제를 해결할 수 있다.

### 인터페이스 분리 원칙 (Inteface Segregation Principle, ISP)

- 특정 클라이언트(인터페이스를 받는 클래스를 따로 클라이언트라고 한다)를 위한 인터페이스 여러 개가 범용 인터페이스보다 낫다. 재사용성이 높고 가독성이 좋기 때문!
- 인터페이스에는 클라이언트가 사용하는 메서드만 존재해야 한다.

![](https://i.imgur.com/H9B0G5L.png)

이렇게 하나의 인터페이스에 몰아넣으면 불필요한 메서드가 많아지고, 정리하기도 쉽지 않다.

![](https://i.imgur.com/kOgfZot.png)

인터페이스를 여러 개로 나누어 관리하자!

### 의존 역전 원칙 (Dependency Inversion Principle, DIP)

- 특정 클래스는 구체적인 구현이 아닌 추상화된 인터페이스나 추상 클래스에 의존하도록 해야 한다.

> [!question]
> - 추상 클래스와 인터페이스의 차이