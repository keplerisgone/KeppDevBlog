---
tags:
  - Dev
---
**함수의 불변성**(**Immutability**)은 함수가 호출된 후에 그 함수의 특성이 변하지 않는 것을 말한다. 여기서 함수의 특성이란 인자로 받는 변수들, 함수 내부의 지역 변수들이 해당한다.

대개 많은 프로그래밍 언어는 메모리에 값을 할당하여 변수로써 저장한다. 해당 변수를 사용할 때 메모리에서 값을 불러와 사용할 수 있다. 이 때, 변수를 불러오는 방법으로는 두 가지가 사용될 수 있는데, 바로 **Call by Reference**와 **Call by Value**이다. 

*Call by Value*는 원시 자료형에서 사용하는 방식으로, **해당 주소에 있는 '값'을 반환하는 방식**이다. 아래의 코드를 보면 이해가 빠르다. (나만)

```cpp
int a = 10; b = 20;

int add(int a, int b){
	a = 20;
	b = 30;
	return a + b
}

std::cout << add(a, b) << "\n";
std::cout << a << " " << b << "\n";
```

위에서는 문자열에 `!`를 붙여 반환하는 함수 `foo()`를 정의하고 사용했다. 함수 `foo()`에 문자열 `str = "Hello!"`를 인자로 준 뒤, 값을 출력해 느낌표가 하나 추가된 `Hello!!`가 출력되는 것을 확인했다. 이 때 원본 문자열 `str`의 값은 바뀌지 않는다. 그저 *값만 전달해 준 것이기 때문이다!*

하지만 *Call by Reference*에서는 상황이 다르다. 값만을 넘겨주는 것이 아닌 *값이 들어있는 주소*를 그대로 넘겨주기 때문에, 해당 함수를 실행할 경우 값이 달라지게 된다.


```cpp
int a = 10, b = 20;
int* pA, pB;
pA = &a;
pB = &b;

int fadd(int* pA, int* pB){
	*pA = 20;
	*pB = 30;
	return *pA + *pB;
}

std::cout << fadd(&a, &b) << "\n";
std::cout << a << " " << b << "\n'";
```

뭐 아무튼 그렇대

근데 이게 불변성이랑 어떤 상관관계를 가질까? 단순하게 설명하자면, Call by Value 방식은 불변성을 해치지 않고, Call by Reference 방식은 불변성을 해친다. 핵심은 **메모리에 담긴 값을 변경하지 않는 것이기 때문이다**. 따라서 만약 당신이 불변성을 고려하며 코드를 짠다면, 인자 전달 방식에 유의해야 할 것이다. 다만 파이썬은 좀 다른데, 이는 [[Python에서의 인자 전달 방식]]을 참고하라.

함수의 불변성을 지키며 작업한다면 다음과 같은 장점을 누릴 수 있다.
 - **무분별한 상태의 변경을 막을 수 있다** : 대개 OOP 등을 다루다 보면 한 객체에서 다른 객체의 변수를 함부로 변경하는 것을 막기 위해 `public, private, protected`와 같은 접근자를 사용한 경험이 있을 것이다. 불변 함수를 사용하는 이유도 이와 같다.
 - **테스트 하기가 쉽다** : 따라서 함수가 변경하는 것은 내부적인 인자들 밖에 없으므로, 자연스럽게 인풋 - 아웃풋 간의 관게에만 집중하면 된다.

하지만 실제 코드를 작성하다 보면 외부 상황에 아무런 영향을 주지 않도록 하는 것이 쉽지 않다. 특히나 쉴새 없이 외부 인풋, 정보와 마주해야 하는 게임 분야라면 더욱 그렇다. 

함수의 불변성은 함수의 부작용과 연관이 깊다. [[함수의 Side Effect]] 문서 참고.
