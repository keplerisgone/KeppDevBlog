## IPC 파악하기

### IPC (Inter-Process Communication) 란?

- 서비스 데몬이란?
  - 백그라운드에서 실행되는 프로그램들
- 보통의 프로세스는 각자만의 사용자 공간을 가지고 있음
  - 이는 다른 프로세스에서 오류가 생겨도 다른 프로세스에 영향이 가지 않게 하기 위함
  - 하지만 다른 프로세스의 사용자 공간에는 접근할 수 없음
- 다른 프로세스와 상호작용을 할 수 있게 하는 것이 **IPC** (Inter-Process Communication)

### IPC의 종류

- 커널이 데이터를 전달 받아 내부 버퍼에 임시로 저장하고 이를 대상 프로세스에 전달
  - Pipe, Name pipe, Socket, Message queue
- 물리 메모리 상에서 동일한 영역을 사용하는 공간을 각각 프로세스에 매핑
  - Shared memory, File-mapped memory
- 데이터가 오가지는 않으나 프로세스끼리 제어권을 위한 신호를 전달
  - Semaphore, Futex, Signal

### 프로세스 생성 및 관리

- `fork()` : 새로운 프로세스를 생성하는 함수, 프로세스를 2개로 복제
  - 2개로 복제되면서 원래의 프로세스는 부모, 새로 생겨난 프로세스는 자식이 됨
  - 반환 값이 0이면 현재 자식 프로세스, 양수이면 헌재 부모 프로세스
- `wait(state), waitpid(state, pid, option)` : 자식 프로세스가 종료될 때까지 기다림
  - state에는 자식의 exit 상태가 반환, 매크로를 이용해 종료 과정을 알 수 있다.
  - WIFEXITED(state), WEXITSTATUS(state)
- 자식 프로세스가 종료되면 부모는 반드새 wait을 통해 결과값을 받아야 함
  - 받지 않으면 좀비 프로세스가 됨
- `execve(filename, argv, env)` : filename의 프로그램을 현재 프로세스에 로드 후 실행
  - argv는 main에 전달되는 인자, 맨 끝은 NULL로 끝나야 함
  - env는 사용할 환경 변수를 "<key>=<value>" 형태의 문자열 배열로 넘김, 마지막은 NULL
  - execve가 실행되면 이전으로는 돌아갈 수 없음
- `getpid()` : 현재 프로세스의 ID 반환
- `getppid()` : 현재 프로세스의 부모 ID 반환

### 파이프 (Pipe)

- 부모 프로세스와 자식 프로세스 사이에서 간단하게 사용할 수 있는 IPC
- 리눅스의 `|` 명령어도 진짜 pipe임ㅋㅋ
  - `dup2(from, to)` : to가 from을 가리키도록 복사
- 단방향 통신임
- `pipd(fd[2])` : 크기가 2인 fd 배열을 받아서 fd[0]에는 읽기 전용, fd[1]에는 쓰기 전용 반환
  - 양방향 통신을 하려면 pipe를 두 개 만들면 된다

### 네임드 파이프 (Named Pipe)

- 부모 자식 간이 아니어도 FIFO 파일의 경로만 안다면 통신이 가능
- `mkfifo(fifo_file, mode)` : FIFO 파일을 지정한 권한으로 생성
- `mkfifo -m <mode>` 명령어로도 생성 가능

### 유닉스 소켓 (Unix Socket)

- 파이프는 단방향이며 여러 요청을 받아서 처리하는 것이 불가능
- 따라서 서버-클라이언트와 같은 복잡한 구조는 파이프로 구현할 수 없음
  - 이전에는 이를 해결하기 위해 Loopback을 사용
  - 자기자신을 가리키는 IP인 127.0.0.1로 connect API 사용
  - 구현에 실수하면 외부 통신이 가능해진다는 단점이...
- 유닉스 소켓은 FIFO 파일처럼 소켓 파일을 제공해 소켓통신이 가능해짐
  - AF_INET 대신 AF_UNIX라는 도메인이 추가로 제공됨
  - IP 주소 대신 소켓 파일의 경로를 bind와 connect API에 사용 가능

### 소켓 통신 흐름

![](<Media/Screenshot\ 2024-08-15\ at\ 14.37.51.png>)

저작권 문제 있다 이거 

### 공유 메모리 (Shared memory)

- 데이터를 공유하기 위해서 다른 프로세스가 동일한 물리 메모리를 매핑하는 경우
- 그렇다고 여러 프로세스가 동시에 같은 영역을 접근하면 안 됨 -> [[#네임드 세마포어 (Named semaphore)]]
- `mmap(start, length, prot, flags, fd, offset)` : 메모리 매핑 함수
  - fd가 실제 파일이면 파일의 일부를 매핑
  - 파일로의 접근을 read/write 호출 없이 일반적인 메모리 접근과 동일하게 사용 가능 (빠르다)
- `shm_open(name, flags, mode)` : name의 이름으로 공유메모리를 오픈
- `ftruncate(fd, size)` : 파일의 크기를 설정

### 네임드 세마포어 (Named semaphore)

- 여러 프로세스가 동시에 같은 자원에 접근하지 않도록 하는 기법
- 뮤텍스와 비슷하지만, 네임드 세마포어는 동시에 접근 가능한 프로세스의 개수를 제한할 수 있음
  -  뮤텍스는 한 번에 하나
- `sem_open(name, flags, mode, value)` : 동시접근 가능한 프로세스의 수를 value로 하는 세마포어 생성
- `sem_wait(post)` : 해당 세마포어에 대해 제어권 획득
- `sem_post(post)` : 해당 세마포어에 대해 제어권 내려놓기

### 시그널 (Signal)

- 프로세스에게 뭔가 통지하고 싶을 때 사용
- `kill -l` : 현재 커널에서 사용 가능한 시그널 목록을 보여줌
- `SIGINT`, `SIGKILL` 등등
- 시그널을 받으면 미리 등록한 시그널 핸들러가 실행됨 
- `signal(signal, handler)` : 시그널 핸들러를 등록
  - SIGKILL과 SOGSTOP은 시그널 핸들러를 등록할 수 없음
  - handler는 시그널 핸들러의 함수포인터, 함수는 void (*) (int) 형태
- `kill(pid, signal)` : 해당 프로세스에 시그널 전송

### 함수의 사용법이 헷갈릴 때 > man

- `man 2 <function>` : 해당 함수에 대한 상세한 도움말을 제공

---

## Systemd 서비스 이해하기

### Systemd란?

- 커널이 가장 처음 띄우는 init 프로세스 (PID : 1) (linux의 경우)
- 시스템을 초기화하며 여러 가지 서비스 데몬을 띄우고 관리함
- udev 데몬도 systemd 서비스로 구동
- 각 서비스 간의 의존성을 자동으로 관리

### 데몬 (Daemon) 이란?

- 여러 요청을 받아 서비스를 제공하는 백그라운드 프로세스
  - 윈도우의 서비스와 같은 역할
- 사용자가 직접 제어 불가, init 시스템 등이 데몬을 관리
- 부모의 PID는 1(init)이어야 하며 세션 및 그룹아이디는 본인이어야 함

### Systemd 서비스 관리하기

- `systemctl status <name>` : name 서비스의 상태를 조회
- `systemctl enable/disable <name>` : name 서비스를 활성화/비활성화
- `systemctl start/stop <name>` : name 서비스를 시작/종료
- `systemctl daemon-reload` : 서비스를 수정하거나 추가했을 때 새로고침
- `systemctl list-units` : 모든 서비스 목록 출력
- `systemctl list-sockets` : 서비스가 사용하는 소켓의 목록을 출력
- `systemctl list-dependencies` : 서비스를 tree 구조로 의존성에 맞춰서 출력
- `journalctl -fn` : 모든 systemd 서비스 데몬의 로그 출력
- `journalctl -fn -u <name>.service` : 모든 systemd 서비스 데몬들의 로그 출력

### Systemd 소켓 활성화 (Socket activation)

- 서비스 데몬의 가장 기본적인 동작 : 소켓을 열고 요정 올 때까지 대기하기
- 이걸 systemd가 하도록 한다
- 접속이 없을 경우 서비스 데몬을 열지 않아 메모리 절약 가능
1. systemd는 소켓을 열고 listen 상태로 둠
2. 소켓에 접속 요청이 들어오면 systemd는 서비스 데몬을 실행
3. 서비스 데몬을 실행되었을 때 accept부터 처리하면 됨
4. 서비스 데몬이 더 이상 처리할 것이 없으면 종료함
5. 요청이 들어올 때마다 반복

### systemd 소켓과 연동하는 데몬 만들기 

- `sd_listen_fds(0)` : systemd로부터 헌재 서비스 데몬에서 사용할 수 있는 소켓 획득

---

## SDK (Software Development Kit) 구성하기

### SDK의 구성요소

- 라이브러리 + 헤더 + API 문서 + 빌드 도구
- 라이브러리 빌드하는 방법 : gcc에 -shared 옵션 추가, 바이너리 파일이름은 lib<name>.so
  - 바이너리 파일은 루트파일시스템의 /usr/lib 밑에 위치해야 함 

### 헤더 파일 구성 방법

- 라이브러리에서 개발자가 사용하게 하고 싶은 함수를 헤더파일에 명시
- 헤더 파일이 두 번 이상 include 되지 않도록 `ifndef`, `define` 을 함께 사용

### SDK의 구성 및 사용법

- gcc에서 헤더파일의 위치와 라이브러리의 위치를 -l과 -L 명령어를 사용해서 지정
- SDK를 구성할 때 보통은 include, lib, doc 폴더를 만듬
- 라이브러리는 루트파일시스템의 /usr/lib 밑에도 복사해야 함
