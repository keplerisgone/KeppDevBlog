#1 시스템 콜이란?
본래 사용자 모드에서는 커널 공간에서 수행 가능한 파일 관리 등의 기능을 수행할 수 없다.
하지만 사용자 모드에서 이런 기능이 필요할 경우가 있을 수 있는데, 이 때 커널에 시스템 콜을 호출하여 커널 모드의 기능을 사용하게 할 수 있다. 
이를 이용해서 사용자 모드에서도 파일 관리 등의 기능을 사용할 수 있다.

#1 strace 명령어를 이용한 시스템 콜 살펴보기
강의에서 배운 ‘strace’ 명령어를 이용해 실행되는 프로세스의 시스템 콜을 추적할 수 있다. 

-	strace <command> : 해당 명령어 실행 시 호출되는 시스템 콜을 화면에 출력
-	strace -o <file> <command> : 해당 명령어 실행 시 호출되는 시스템 콜을 파일에 저장
-	strace -o <file> -c <command> : 해당 명령어 실행 시 호출되는 시스템 콜의 개수를 표로 출력

위와 같이 ‘strace’를 이용해 ‘ls’ 명령어가 실행될 때 호출되는 시스템 콜의 정보를 알아보고자 한다. 알고자 하는 정보는 다음과 같다.

-	ls 명령어에서 호출한 모든 시스템 콜 호출 목록
-	ls 명령어에서 사용하는 시스템 콜의 종류별 호출 횟수
-	ls 명령어에서 읽는데 성공한 모든 파일의 경로

#2 ls 명령어에서 호출한 모든 시스템 콜 호출 목록

ls 명령어는 Linux 및 Unix 계열 운영체제에서 자주 사용되는 명령어로, 
현재 디렉토리 또는 지정한 디렉토리에 존재하는 파일이나 다른 디렉토리를 나열하는 기능을 수행한다. 
strace 명령어를 이용해 ls 명령어가 호출하는 시스템 콜을 알아보자. 
각 시스템 콜의 종류 및 인자, 반환 값을 알아야하므로 기본적인 strace 명령어를 사용한다.
 
결과를 output.txt 에 저장한 후 cat 명령어를 이용해 내용을 출력해보았다.
   
strace 명령어를 이용해 호출된 시스템 콜을 보는 방법은 다음과 같다.

-	각 줄은 하나의 시스템 콜 호출을 나타낸다.
-	처음 단어는 시스템 콜의 이름이며, 괄호 안의 값들은 인자로 전달되는 값이다.
-	‘=’ 뒤의 값은 시스템 콜의 반환 값이다. 

이에 따라 호출된 시스템 콜을 분석하면 다음과 같다. 
각 시스템 콜의 기능 및 인자, 반환 값 정보는 https://man7.org/linux/man-pages/index.html를 참고하였다.

-	execve : 현재 프로세스를 지정된 프로그램으로 대체한다. 인자로 실행할 프로그램의 경로를 받으며, 위에서는 ‘ls’ 라는 명령어를 실행시키기 위해 해당 함수가 담긴 실행 파일의 경로를 인자로 하는 것으로 추정할 수 있다.

-	brk : 데이터 세그먼트의 끝을 지정한다. 즉 프로그램이 사용하는 메모리의 크기를 조정하는데 사용된다. 다만 brk(NULL)은 현재 사용하는 메모리의 끝 주소를 알아내는데 사용하는 시스템 콜이다. 따라서 위 반환 값 또한 주소의 형태를 가지는 것을 확인할 수 있다.
-	mmap
호출한 프로세스의 가상 주소 공간에 이용할 메모리 공간을 생성한다. (메모리 매핑) 인자로는 메모리 매핑을 수행할 주소, 메모리 크기, 메모리 보호 모드(권한), 매핑 옵션, 파일 디스크럽터, 오프셋을 받으며, 메모리 매핑이 시작된 메모리 주소를 반환한다. (포인터)
-	arch_prctl
아키텍처 별 프로세스나 스레드 상태를 설정한다. 인자로는 연산의 종류와 메모리 주소를 받는다. 위에서 한 번 실행된 콜에서는 ARCH_SET_FS를 인자로 받는데, 이는 FS 레지스터의 64비트 기본값을 인자로 받은 주소로 설정하는 연산을 진행하라는 것이다.
-	set_tid_address
커널은 각 스레드에 대해서 set_child_tid와 clear_child_tid 라는 두 가지 thread id를 유지한다. set_tid_address는 인자로 메모리 주소를 가리키는 포인터를 받아 clear_child_tid를 이것으로 설정한다.
-	set_robust_list
커널에 호출한 스레드가 가진 robust 퓨텍스 리스트의 head를 기록하도록 요청한다. 인자로는 기록할 head와 head가 가리키는 데이터의 크기이다.
-	rseq
특정 시퀀스를 중단 없이 실행할 수 있게 한다. 사용할 시퀀스에 대한 정보를 담는 포인터와 그 포인터가 가리키는 구조체의 크기를 인자로 받는다.
-	mprotect
특정 메모리 공간에 대한 접근 권한을 바꾼다. 인자로는 권한을 바꾸고자하는 메모리 공간의 주소와 길이, 권한을 받는다. 
-	prlimit64
임의의 프로세스에 대한 리소스 제한을 설정하거나 리소스를 가져오는 기능을 수행한다. 이는 리소스 제한을 설정하는 setrlimit과 리소스를 가져오는 getrlimit의 기능이 결합된 것이다. 
-	munmap
현재 프로세스가 사용하는 메모리 공간의 특정 범위에 대한 매핑을 제거한다. 인자로는 매핑을 지우고자 하는 메모리 공간의 시작 주소와 크기를 받는다. 
-	statfs
마운트된 파일시스템 내의 파일 경로를 받아 그에 대한 정보를 반환한다. statfs 구조에 대한 포인터를 추가로 입력받으며, 받은 파일 정보는 statfs 구조체에 저장된다.
-	getrandom
임의의 랜덤 난수를 생성한다. 이는 인자로 받는 버퍼를  flags를 기반으로 해 랜덤한 바이트만큼 채우는 원리로 동작한다. 
-	access
호출한 프로세스가 인자로 받은 파일 경로명에 액세스할 수 있는지 여부를 확인한다. 정확히는 파일에 대한 권한을 알리는 것이 아닌, “사용자가 가지는 이 파일에 대한 권한”을 반환한다.
-	openat
인자로 파일의 경로명을 받아 해당 파일의 파일 설명자를 반환한다. 파일 설명자(디스크립터)는 해당 파일에 대한 정보를 담는 파일 설명을 참조한다. 일반적인 open 콜은 절대 경로를 받지만, openat은 상대 경로를 받는다.
-	fstat
파일에 대한 정보를 받고 이를 버퍼 인자가 가리키는 stat 구조체에 저장한다. 작업을 수행한 후에는 성공 여부를 반환한다.
-	close
파일 디스크립터를 닫아 파일을 참조하지 않도록 해 재사용이 가능하도록 한다. 파일 디스크립터와 연결된 파일은 모두 연결이 제거된다. 인자로는 파일 디스크립터를 받으며, 성공 여부를 반환한다.
-	read
파일 디스크립터를 인자로 받아 지정한 바이트 수 만큼 파일을 읽으려고 시도한다. 파일을 읽는데 성공할 시 읽은 바이트 수가 반환된다. 
-	pread64
파일의 시작 부분부터 파일 디스크립터의 바이트 수만큼 읽는다. 읽은 바이트 수를 반환한다.
-	ioctl
터미널과 같은 기본 장치의 매개변수를 조작한다. 인자로는 파일 디스크립터, 장치에 따른 연산 코드를 받는다.
-	getdents64
파일 디스크립터가 참조하는 디렉토리에 존재하는 여러 개의 linux_dirent 를 읽는다. 이는 파일의 이름이나 길이, 파일의 타입을 담는다.
-	write
인자로 버퍼가 시작하는 주소를 받고, 파일 디스크립터를 추가로 받아 이것이 참조하는 파일에 내용을 쓴다. 

#2 ls 명령어에서 사용하는 시스템 콜의 종류별 호출 횟수
다음은 ls 명령어를 사용했을 때 호출되는 시스템 콜의 종류별 호출 횟수를 알아보고자 한다. 
이를 알기 위해서는 각 시스템 콜의 호출 횟수를 표로 정리해 보여주는 strace -c 명령어를 이용해야 한다.
 
해당 결과를 output.txt에 저장한 뒤 cat 명령어를 이용해 출력해보았다.
 
위 과정을 통해 각 시스템 콜의 호출 횟수 및 실행 시간을 알 수 있었다. 가장 많이 호출된 시스템 콜의 종류는 mmap이지만, 가장 오랜 시간을 차지한 시스템 콜은 한 번밖에 호출되지 않은 execve였다. 

#2 ls 명령어에서 읽는데 성공한 모든 파일의 경로

다음은 ls 명령어가 읽는데 성공한 파일의 경로들을 알아보고자 한다. 
파일을 읽는데 사용하는 시스템 콜은 openat이다. 
openat은 파일의 경로를 받아 해당 파일에 대한 디스크립터를 반환하므로, 디스크립터가 반환되면 읽는데 성공한 파일이라고 할 수 있다.
시스템 콜 중 openat이 호출된 경우만을 보기 위해 strace 명령어를 이용해 출력한 결과를 grep으로 전달한다.
 
위에서 파일 경로를 추리면 “/etc/ld.so.cache”, “/lib/x86_64-linux-gnu/libselinux.so.1”, “/lib/x86_64-linux-gnu/libc.so/6”, “/lib/x86_64-linux-gnu/libpcre2-8.so.0”, “/proc/filesystems”, “/usr/lib/locale/locale-archive”, “.”을 읽는데 성공했음을 알 수 있다.

