## 커널 모듈 만들기 

커널 모듈에 대한 이해를 한 후, 이를 만들어 보자.

### 로드 가능한 커널 모듈

- 커널의 이미지에는 포함되지 않지만 커널의 기능을 확장할 수 있는 바이너리 파일
  - 커널 이미지에 포함되지 않기 때문에 부팅시간과 메모리를 절약 가능
  - 소스코드를 별도로 구성해서 빌드할 수 있음
- 커널과는 분리되기 때문에 커널을 다시 시작하지 않아도 커널 기능을 확장할 수 있다.
- 모듈은 커널 주소 공간에서 실행되므로 루트 권한이 있어야 로드가 가능

### 커널 설정 문법 알아보기

- `menu ~ endmenu` : 설정 메뉴 추가
- `config <setting-name(CAPITAL)>` : Makefile과 코드에서 사용할 이름을 지정
  - `tristate <description>` : 3가지 설정값을 가짐
    - Y : 커널에 포함, N : 미포함, M : 모듈로 빌드
  - `bool <description>` : 2가지 설정값을 가짐
    - Y : 커널에 포함, N : 미포함
  - `default <default>` : 별도로 설정하지 않았을 때 사용할 값
  - `depends on <setting>` : 해당 설정이 의존하고 있는 다른 설정을 지정
    - 의존하고 있는 설정이 설정되어 있지 않으면 아예 해당 설정 항목이 보이지 않음
    - `help <description>` : Help 로 봤을 때 보이는 상세한 설명

- 이후 만든 설정은 `menuconfig`를 통해 새로 추가한 설정을 확인하고 활성화 가능

### 모듈의 소스 코드

[TODO] - 이미지 추가

- `linux/module.h` 헤더 파일이 필요
- `__func__` 를 이용해 현재 함수 출력 가능
- `module_init` 함수를 이용해 모듈 로드시에 실행할 함수 지정
- `module_exit` 함수를 이용해 모듈 언로드새에 실행할 함수 지정
- `MODULE_AUTHOR`, `MODULE_DESCRIPTION`, `MODULE_LICENSE` 를 이용해 정보를 기입
  - 라이선스는 반드시 GPL v2여야 함 

### 실습! - 커널 모듈 추가하기

[TODO]

---

## 커널 API, 자료구조 이해하기

### 메모리 관련 함수

- `copy_from_user(to, from, size)` : 사용자 공간에서 커널 공간으로 메모리 복사
- `copy_to_user(to, from, size)` : 커널 공간에서 사용자 공간으로 메모리 복사
- 커널에서 사용자 공간을 직접 접근하지 못함 (보안 이슈)
- 따라서 메모리 복사를 이용해 간접적으로 접근
- 반환하는 값은 복사를 실패한 byte 수

- `kmalloc(size, type)`, `kzalloc(size, type)` : 커널 공간에서 메모리 동적 할당
- type은 `GFP_KERNEL`을 사용하는 것이 일반적
  - `GFP_KERNEL` : 메모리 확보할 때까지 대기
  - `GFP_ATOMIC` : 메모리가 충분하지 않으면 NULL 반환
  - `GFP_DMA`    : 하드웨어에서 사용하기 위한 메모리

- `kfree(pointer)` : kmalloc, kzalloc으로 할당받은 메모리 해제


### 양방향 링크드 리스트 (Double Linked List)

- 커널에서 가장 많이 사용하는 자료구조
- `linux/list.h` 에 관련 함수와 구조체가 정의되어 있음 
  `list_head` 구조체를 사용하여 원하는 구조체를 노드로 쉽게 사용 가능

#### 링크드 리스트 사용하기

- `node` : 리스트에 들어있는 하나의 노드 (pointer)
- `head` : 링크드리스트를 가리키는 head pointer 

- `LIST_HEAD(name)` : 링크드 리스트 선언
- `list_add(new, head)` : 맨 앞에 새로운 노드 추가
  - `list_add_tail(new, head)` : 맨 뒤에 새로운 노드 추가
- `list_del(target)` : 해당 노드를 리스트에서 제거
- `list_empty(head)` : 링크드 리스트가 비어있는지 확인 
- `list_for_each(node, head, member){}` : 링크드 리스트를 하나씩 순회하면서 동작
  - node에는 각각의 노드가 들어옴
  - member는 list_head 타입의 변수 이름
  - 중간에 리스트를 수정할 경우 `list_for_each_entry_safe(node, temp, head, member_name)` 사용

### 해시테이블 (Hash Table)

- 데이터 검색의 시간 복잡도를 줄이기 위한 자료구조 

- `DEFINE_HASHTABLE(name)` : 해시테이블 선언
- `hash_add(table, new, key)` : 새로운 노드 추가
- `hash_del(target)` : 노드 삭제
- `hash_for_each_possible(table, node, member, key){}` : key에 해당하는 해시테이블 순회
  - node, member의 사용은 위와 같음 
  - key 값이 달라도 hash 값이 같을 수 있으므로, key가 일치하는지 검사 필요
- `hash_for_each(table, kt, node, hash)` : 모든 노드를 순회
  - `hash_for_each*_safe(*)` : 순회할 때 해시테이블을 수정해야 한다면 사용

### 뮤텍스 (Mutex - Mutual Exclusive)

- 동시에 실행하면 안 되는 부분을 지정
- 한 번에 프로세스 하나만 접근이 가능
- 오래 기다려야 한다고 가정하고 컨텍스트 스위칭이 일어나게 됨 
  - 제어권이 바로바로 바뀐다고 가정했을때는 스핀락(Spinlock)이 유리

- `DEFINE_MUTEX(name)` : 새로운 뮤텍스 선언
- `mutex_lock(mutex)` : 해당 뮤텍스에 대해 제어권 획득
- `mutex_unlock(mutex)` : 해당 뮤텍스에서 얻은 제어권 내려놓음
  - mutex_lock에서 대기하고 있던 프로세스 하나가 제어권을 획득하게 됨

### 스핀락 

- 기본적인 내용은 뮤텍스와 동일
- 무한루프를 사용하여 스레드가 락을 풀 수 있을 때까지 대기
- 컨텍스트 스위칭은 일어나지 않음
- Read-Write lock 이라고 불리는 형태를 많이 사용
  - 데이터를 읽는 경우는 한 번에 여러 프로세스를 허용
  - 데이터를 쓰는 경우는 한 번에 한 프로세스를 허용
  - 쓸 때는 아무것도 못함!!!!

- `DEFINE_RWLOCK(name)` : 새로운 스핀락 선언
- `read_lock(spinlock)` / `write_lock` : 해당 스핀락에 대해 읽기/쓰기 제어권 획득
- `read_unlock(spinlock)` / `write_lock` : 해당 스핀락에 대해 읽기/쓰기 제어권을 내려놓음

### 현재 프로세스 (Current task) 

- `current` : 현재 프로세스를 참조하고 전역 변수로 커널 어디에서나 사용이 가능
  - aarch64에서는 특정 레지스터에 항상 주소를 보관하고 있음
  - 전역변수처럼 사용하지만 사실은 macro와 inline 함수
- `task_struct` 구조체
  - `pid` : 현재 프로세스 ID
  - `mm` : 현재 프로세스의 메모리 및 주소공간 정보
  - `comm` : 현재 프로세스의 프로그램 이름
  - `cred` : 현재 프로세스의 로그인 정보

> [!note]
> 커널의 API와 자료구조가 헷갈릴 때는 : [bootlin](https://elixir.bootlin.com/linux/latest/source)
> 아니면 grep을 이용해 커널 소스코드를 찾는 방법도 있다

---

## 디바이스 드라이버 개발하기

### 디바이스 드라이버의 종류 

- 문자 디바이스 드라이버 : 대부분의 디바이스 드라이버에 해당.
- 블록 디바이스 드라이버 : 대용량의 데이터를 저장하는 디바이스에 대해 사용
- 네트워크 디바이스 드라이버 : 외부와 통신을 하며 특히 소켓을 사용하여 통신하는 디바이스에 대해 사용
- 버스 디바이스 드라이버 : USB나 PCI 등 여러 다른 디바이스가 꽂히는 포트 디바이스에 대해 사용

### 디바이스 노드

- 디바이스 드라이버를 다루기 위한 특수한 파일
- 모든 디바이스 노드는 고유의 타입, 주번호, 부번호를 가짐
- 타입 : 문자형 (c), 블록형 (b)
  - 네트워크나 버스 디바이스 드라이는 노드로 노출되지 않음
- 주번호 (Major) : *디바이스 드라이버*를 구분하기 위한 번호
  - 커널이 할당하기도 함
- 부번호 (Minor) : *디바이스*를 구분하기 위한 번호
  - 디바이스 드라이버가 할당을 관리함
- 하나의 디바이스 드라이버에 디바이스 여러 개가 할당될 수 있음

- `mknod <file> <type> <major> <minor>` : 디바이스 노드 파일 생성
  - 일반적으로 `/dev`에만 생성하여 관리

### 문자 디바이스 (Character Device Driver)

- `file_operations`를 구현하는 디바이스 드라이버
  - `open`, `read`, `write`, `lseek`, `close`  등 일반적으로 사용하는 파일 함수 
  - 별도의 시스템콜 추가 없이도 간편하게 새로운 기능 추가 가능 (가상 파일 시스템)
  - [[04-운영체제-이론-맛보기-개념#운영체제의-목적#가상 파일 시스템]]

#### 파일 열기 / 닫기 구현

- `int (*open)(inode, file)` : 파일 열기 동작 구현
- `void (*release)(inode, file)` : 파일 닫기 동작 구현

- `inode` : 파일에 대한 정보를 명시하는 구조체
  - `i_rdev` : 디바이스 노드의 주번호와 부번호를 나타내는 번호
  - `MAJOR()`, `MINOR()` 매크로를 이용해 주번호와 부번호를 추출 가능
- `file` : open 으로 열었을 때 반환되는 fd (file descriptor)의 커널 데이터
  - `f_inode` : 파일 정보를 가지고 있는 inode
  - `f_cred` : 파일을 열었을 때의 로그인 정보 (사용자 및 그룹 아이디)
  - `f_pos` : 현재의 파일 커서 위치 (cf. lseek 함수)
  - `f_mode` : open으로 파일을 열 때 사용한 모드
  - `private_data` : 커널에서 사용할 수 있는 임시 데이터

#### 파일 읽기 / 쓰기 구현

- `ssize_t (*read) (file, buf, len, ppos)` : 파일 읽기 동작 구현
- `ssize_t (*write) (file, buf, len, ppos)` : 파일 쓰기 동작 구현 

- buf와 len은 사용자가 read/write 함수로 넘겨주는 인자
- ppos는 현재의 위치를 나타내는 커널이 넘겨주는 인자
- 반환 값은 실제로 복사한 byte 수

#### 파일 특수 제어 (ioctl) 구현

- `long (*unlocked_ioctl) (file, cmd, arg)` : 파일의 특수 제어 동작을 구현
- 단순 읽기/쓰기가 아닌 디바이스를 설정하거나 설정을 확인하는 동작을 구현할 때 사용
- cmd는 일반적으로 _IOW, _IOR을 사용해서 정의
  - `_IO(type, nr)` : arg 없이 단순한 명령어   
  - `_IOW(type, nr, size)` : arg로 size 만큼의 데이터를 넘김, 데이터 쓰기 동작
  - `_IOR(type, nr, size)` : arg로 size 만큼의 데이터를 넘김, 데이터 읽기 동작
  - type은 디바이스 고유의 char 하나
  - nr은 명령의 고유한 숫자를 의미 (정의)

---

## udev와 연동하기

### udev란?

- 디바이스 드라이버를 추가하기 위해서는 `/dev`에 디바이스 노드도 추가해야 함
  - 그럼 디바이스의 주번호를 미리 알아야 함???
  - 자동으로 인식되는 디바이스는 불리하겠네
- udev는 이를 해결하기 위해 만들어짐

1. 새로운 디바이스가 인식되면 커널이 uevent를 발생, udev 데몬에게 이를 알림
2. udev 데몬은 /sys 를 확인해 디바이스에 대한 정보를 알아냄
  - 커널이 /sys/devices와 /sys/class 에 새로운 디바이스에 대한 디렉토리를 생성하기 때문
3. udev 데몬은 dev 파일을 읽어 주번호와 부번호를 알아내 새로운 디바이스 노드를 /dev에 생성

### 디바이스 생성을 udev에게 알리기

- `class_create(owner, name)` : 새로운 디바이스 클래스 생성
  - owner는 어떤 모듈에 속해 있는가를 나타내며, 일반적으로 THIS_MODULE 지정
  - 클래스는 비슷한 종류의 디바이스를 하나로 묶어서 관리하게 해줌
  - /sys/class 밑에 클래스 이름의 디렉토리 생성
- `device_create(class, paren, dev_no, data, name)` : 새로운 디바이스 생성
  - parent는 부모 디바이스를 나타냄, NULL로 지정 가능
  - dev_no는 MKDEV(major, minor) 매크로를 통해 주번호와 부번호를 나타냄
  - /sys/class/<name> 과 /sys/devices/ 에 새로운 디렉토리와 dev 파일 생성
