# 데이터 프로세싱 

데이터는 클럭에 맞춰 0과 1로 이루어진 형태로 보내진다. 각각의 0과 1을 bit(비트)라고 하고, 0과 1로 이루어진 데이터를 bit sequence (비트 시퀀스)= raw data(로우 데이터)라고 한다.
데이터의 크기를 quantity라고 하며, 데이터를 한 번에 보낼 수 있는 양은 bandwidth라고 한다.

## 코딩과 디코딩 

**인코딩** (encoding)은 데이터를 다른 형태로 가공하는 것을 의미한다. 코딩(coding)도 같은 의미로 사용되는데, 우리가 하는 코딩 또한 프로그래밍 언어를 기계어로 가공한다는 점에서 맞는 말이다.
**디코딩** (decoding)은 인코딩의 역순이다. 

### 트랜스코딩 (transcoding)

**트랜스코딩** (transcoding)은 이미 특정 형태로 인코딩된 데이터를 다른 형태로 다시 인코딩하는 것을 말한다. 
흔히 쓰는 word -> pdf 변환같은 것을 생각하면 된다.

### MUXing vs DEMUXing

먹싱(MUXing)은 데이터를 효율적으로 보내기 위해 데이터를 섞는 것을 말한다. 디먹싱(DEMUXing)은 섞인 데이터를 원래 순서로 다시 배열하는 것을 말한다. 
비디오 데이터와 오디오 데이터를 보내는 것을 상상해보자!

## 비트연산, 데이터 포맷

- 2진법 (binary) : 숫자를 0과 1로 표현, b를 앞에 붙인다.
- 16진법 (hexadecimal) : 숫자를 0~F로 표현, 0x를 앞에 붙인다.
- 비트 연산인 AND, OR, SHIFT, XOR을 잘 기억하자.
- **msb** : most significant bit의 약자로, 가장 높은 자리의 *비트*를 뜻한다.
- **MSB** : most significant byte의 약자로, 가장 높은 자리의 *바이트*를 뜻한다.
- **lsb** : least significant bit의 약자로, 가장 낮은 자리의 *비트*를 뜻한다.
- **LSB** : least significant byte의 약자로, 가장 낮은 자리의 *바이트*를 뜻한다.

가장 낮은, 높은 자리로 구분한 이유는 아래서 설명할 바이트 오더링에 따라 높은, 낮은 바이트와 비트의 위치가 달라지기 때문이다. 

## 바이트 오더링 (Byte Ordering) = 엔디안 (Endian)

**바이트 오더링**(Byte Ordering), 다른 말로 하면 **엔디안**(Endian)은 데이터를 저장하는 방식, 더 정확히는 저장된 데이터를 해석하는 방식을 의미한다. 
가장 중요한 사실은 데이터의 기본 단위가 **비트와 바이트** (bit and byte)라는 것이다!!

엔디안은 이 **비트와 바이트**를 기준으로 데이터를 메모리에 어떤 순서로 저장할 것인가를 나타낸다. 엔디안은 크게 두 가지로 나뉜다.
- Little Endian (리틀 엔디안, LE) : 작은 바이트를 먼저 앞에서부터 저장한다.
- Big Endian (빅 엔디안, BE) : 큰 바이트를 먼저 저장한다.

예를 들어, 0x12345678 (4byte INT)을 메모리에 저장한다고 하면, 다음과 같이 저장된다.

- 리틀 엔디안의 경우)

| Address | 0x00 | 0x01 | 0x02 | 0x03 |
|---------|------|------|------|------|
| DATA    | 0x78 | 0x56 | 0x34 | 0x12 |

- 빅 엔디안의 경우)

| Address | 0x00 | 0x01 | 0x02 | 0x03 |
|---------|------|------|------|------|
| DATA    | 0x12 | 0x34 | 0x56 | 0x78 |

일반적인 형변환은 엔디안과 상관없이 일어난다. (메모리 위치에 영향을 안 받는 경우)
하지만 메모리의 영향을 받는 경우에는 엔디안에 따라 형변환이 다르게 일어난다.
```
CHAR a[] = {0x12, 0x34, 0x56, 0x78}
```

| Address | 0x00 | 0x01 | 0x02 | 0x03 |
|---------|------|------|------|------|
| DATA    | 0x12 | 0x34 | 0x56 | 0x78 |

위 경우는 엔디안에 상관없이 앞에서부터 차례대로 메모리에 저장된다. 이를 INT로 형변환하면 리틀 엔디안에서는 뒤부터 읽어 `0x78563412`가 되고, 빅 엔디안에서는 `0x12345678`이 된다. 

형변환의 타입대로 앞에서부터 자르고, 엔디안에 따라 해석된다고 생각하면 된다. 

> [!note]
> 32비트 프로세서에서 64비트를 처리하는 법?

컴파일러가 64비트 변수를 보고 32비트 메모리 두 개를 합칠 수 있는 능력이 있으면 합격! 사실 큰 변수는 buffer를 이용해 처리하기 때문에 64비트에 집착할 필요는 없다. 속도가 짱 느려질 뿐...

## 타이밍 다이어그램 

**타이밍 다이어그램**(Timing Diagram)은 각 신호를이 시간에 따라 처리되는 과정을 시각적으로 나타낸 것이다. 

- 우선 clk (clock)은 주기적으로 움직여 기준이 된다.
- Data 파형은 clk에 맞춰서 움직이며 이를 읽으면 데이터를 읽을 수 있다.

clk이 Low에서 high로 갈 때를 **rising edge**라고 하며, high에서 low로 갈 때는 **falling edge**라고 한다. 둘 중에 하나를 골라 데이터를 읽는 기준으로 삼는다. 각 edge에서 데이터 파형을 읽는다. (=fetch)

실제 타이밍 다이어그램은 육각형스러운 모습으로 나타나며, high <-> low로 변하는 시간이 반영되어 있다. 이 시간은 데이터시트에 나타나 있다.

신호 파형의 상태는 다음과 같이 나뉠 수 있다.
- (Active, Valid) Low/High : 글자 그대로
- Transition Low/High : 언제든지 해당 상태로 바뀔 수 있는 상태
- Floating = Tri-state = High-Z : High도 Low도 아닌 상태 
- Rising/Falling edge : 신호가 변하는 순간!!


