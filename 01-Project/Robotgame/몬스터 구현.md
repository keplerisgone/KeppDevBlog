---
tags:
  - Unity
  - Project
---
## 전체 구조

## 기본 - TestEnemy.cs

몬스터의 기본적인 사항(현재는 *데미지 입기*)을 담당하는 스크립트.
```cpp
public class TestEnemy : MonoBehaviour
{
    public int hp = 5;
    public GameObject coin;

    public void TakeDamage(int damage)
    {
        if (hp == 1)
        {
            int coins = Random.Range(0, 5);
            for (int i = 0; i < coins; i++)
            {
                Instantiate(coin, transform.position, transform.rotation);
            }
            Destroy(gameObject);
        }
        hp = hp - damage;
    }
}
```

단순히 몬스터의 체력을 설정하고, 피해를 입으면(*다른 외부 스크립트에서 실행해야 함*) 체력을 깎는다. 체력이 모두 떨어지면 코인을 드랍하고 사망한다. 아래는 사용 함수이다.

### TakeDamage(int damage)
- 몬스터에게 데미지를 입힌다
- 단독으로 사용되지는 않고, 외부 공격 오브젝트에서 호출하는 식으로 사용한다
	- 주로 OnCollisionEnter2D 등에서 GetComponent를 이용해 호출할 듯
- 죽으면 코인을 뿌림

## 몬스터 이동(AI) - TestEnemyAI.cs

어쩌다보니 몬스터의 *이동, 넉백, 추적*을 모두 담당하는 스크립트가 되었다.
우선적으로는 랜덤한 이동방향으로 이동하며, 일정 범위내에 플레이어가 들어왔을 경우 플레이어를 추적한다. 또한 넉백이 호출되었을 경우 밀려난다. 낭떠러지 방향 전환은 **FixedUpdate()** 에 통째로 구현되어있다. 레이캐스트를 활용.
```cpp
public class TestEnemyAI : MonoBehaviour
{
    [Header("moveAI")]
    public float moveSpeed = 1.0f;
    public bool isTracing = false;
    public int nextMove;
    
    [Header("Knockback")]
    public float knockbackTime = 0.2f;
    public float hitDirectionForce = 10f;
    public float constForce = 5f;
    public bool isKnockback;
    public Coroutine knockback;
    
    public SpriteRenderer render;
    public GameObject target;
    public Rigidbody2D rb;
    
    private void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        render = GetComponent<SpriteRenderer>();

        StartCoroutine("Think");
    }

    private void FixedUpdate()
    {
        if (!isKnockback)
        {
            Walk();
        }

        // 낭떠러지 방향 전환
        Vector2 frontRay = new Vector2(rb.position.x + nextMove * 0.5f, rb.position.y);
        RaycastHit2D rayHit = Physics2D.Raycast(frontRay, Vector3.down, 1, LayerMask.GetMask("Ground"));
        if (rayHit.collider == null && isTracing == false)
        {
            StopCoroutine("Think");
            // 방향 전환 후 다시 think 시작
            nextMove *= -1;
            render.flipX = nextMove == 1;
            StartCoroutine("Think");
        }
    }

    private void Walk()
    {
        // 플레이어 추적시 방향 설정
        if (isTracing == true)
        {
            Vector3 targetPos = target.transform.position;
            if (targetPos.x < transform.position.x)
                nextMove = -1;
            else if (targetPos.x > transform.position.x)
                nextMove = 1;
        }
        // 몬스터 방향 설정
        rb.velocity = new Vector2(nextMove * moveSpeed, rb.velocity.y);
    }

    IEnumerator Think()
    {
        // 랜덤 시간마다 방향 전환
        nextMove = Random.Range(-1, 2);
        float nextThinkTime = Random.Range(2f, 3f);
        yield return new WaitForSeconds(nextThinkTime);
        StartCoroutine("Think");
    }

    public IEnumerator KnockbackAction(Vector2 hitDirection, Vector2 constForceDirection)
    {
        isKnockback = true;
        
        Vector2 _hitForce;
        Vector2 _constForce;
        Vector2 _combinedForce;

        _hitForce = hitDirection * hitDirectionForce;
        _constForce = constForceDirection * constForce;
    
        // 타이머 생성
        float count = 0f;
        while (count < knockbackTime)
        {
            count += Time.deltaTime;
            _combinedForce = _hitForce + _constForce;
            
            // 넉백 적용
            rb.velocity = _combinedForce;

            yield return new WaitForFixedUpdate();
        }

        rb.velocity = Vector2.zero;
        isKnockback = false;
    }

    public void CallKnockback(Vector2 hitDirection, Vector2 constForceDirection)
    {
        knockback = StartCoroutine(KnockbackAction(hitDirection, constForceDirection));
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        // 플레이어 추적, 무작위 이동은 비활성화
        if (other.gameObject.CompareTag("Player"))
        {
            target = other.gameObject;
            isTracing = true;
            StopCoroutine("Think");
        }
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        // 플레이어 추적 비활성화, 무작위 이동
        if (other.gameObject.CompareTag("Player"))
        {
            isTracing = false;
            StartCoroutine("Think");
        }
    }
}
```
### Walk()
- nextMove 변수에 따라 몬스터의 속도를 설정
- 만약 플레이어를 추적중인 경우 플레이어 방향으로 이동한다

### Think()
- 코루틴으로 실행
- 랜덤한 시간마다 몬스터의 방향을 nextMove 변수에 랜덤으로 할당한다
- 일종의 재귀 방식으로 실행된다

### KnockbackAction(Vector2 hitDirection, Vector2 constForceDirection)
- [[플레이어 구현#IEnumerator KnockBackAction(Vector2 hitDirection, Vector2 constForceDirection, float inputDirection)|플레이어 구현에서의 넉백]]과 거의 동일한 방식으로 구현
- *isKnockback* 변수에 따라 몬스터의 이동을 활성화, 비활성화한다
- 코루틴으로 실행된다

### CallKnockback(Vector2 hitDirection, Vector2 constForceDirection)
- 역시 [[플레이어 구현#CallKnockback(Vector2 hitDirection, Vector2 constForceDirection, float inputDirection)|플레이어 구현에서의 넉백]]과 동일
- 외부에서 넉백을 호출할 때 필요한 함수

### OnTriggerEnter2D, OnTriggerExit2D 
- 플레이어의 충돌을 감지
- 해당 플레이어를 추적
- 타겟을 플레이어로 설정

## 몬스터 공격 - TestEnemyAttack.cs

몬스터의 *공격 알림, 공격*을 담당하는 스크립트. 몬스터에 적용하는 것이 아닌, 몬스터의 하위 오브젝트인 *공격 감지 범위*에 적용한다. [[Prefab 모음#Alert|알림]]과 [[Prefab 모음#Atk1|몬스터 공격]] 오브젝트를 사용했다.
```cpp
public class TestEnemyAttack : MonoBehaviour
{
    private bool aiEnabled = false;
    private float attackDelay = 0.7f;

    public GameObject alert;
    public GameObject atkObject;
    
    private void Awake()
    {
        // AI 활성화 여부
        aiEnabled = transform.parent.GetComponent<TestEnemyAI>().enabled;
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        // 공격 범위내 플레이어 들어올시 공격
        if (other.gameObject.CompareTag("Player"))
        {
            StartCoroutine("AttackWait");
        }
    }

    IEnumerator AttackWait()
    {   
        // 공격 준비, 위험 표시 오브젝트 생성
        aiEnabled = false;
        Vector3 alertPos = transform.position + Vector3.up;
        GameObject _alert = Instantiate(alert, alertPos, transform.rotation);
        _alert.transform.SetParent(transform);
        yield return new WaitForSeconds(attackDelay);
        StartCoroutine("Attack");
    }

    IEnumerator Attack()
    {
        // 공격, 공격 오브젝트 생성
        GameObject _atkObject = Instantiate(atkObject, transform.position, transform.rotation);
        _atkObject.transform.SetParent(transform);
        yield return new WaitForSeconds(1f);
        aiEnabled = true;
    }
}
```

### OnCollisionEnter2D 
공격 범위에 플레이어가 들어왔는지 감지한다.

### AttackWait()
* 공격을 준비한다 + 몬스터의 속도를 0으로 줄인다
	* 주의할 점은 해당 오브젝트가 아닌 부모의 속도를 0으로 줄여야 한다는 점
* [[Prefab 모음#Alert|알림 오브젝트]]를 생성
* 딜레이까지 기다린 뒤에 진짜 공격을 실행

### Attack()
- [[Prefab 모음#Atk1|공격 오브젝트]]를 생성하여 공격을 시행한다
- 굳이 마지막에 1초를 기다리는 이유는 움직이지 말라고...
- enable을 시행하면 바로 스크립트가 실행될까? Awake문이 실행될까 Start()문이 실행될까? -> 되면 내가 생각한대로 구현할 수 있음 -> 안되는듯