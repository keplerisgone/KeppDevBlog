# 운영체제의 목적

- 컴퓨터의 자원을 효율적으로 운영 및 관리
- 자원을 보호하기도 함
- 자원에 접근할 수 있는 인터페이스 제공

# 운영체제의 구성

- 하드웨어의 바로 위에서 커널 동작
- 커널의 위에서 응용프로그램이 동작

## 커널 모드, 사용자 모드

- 커널 모드(Kernel mode)

  - 커널을 보호하기 위한 모드
  - CPU 명령어 사용 가능, 하드웨어 직접 조작 가능
  - 커널이 동작하는 곳, 커널 이외의 부분은 반드시 사용자 모드에서 동작
  - 커널 모드가 권한이 더 높음
  - 커널 모드는 CPU가 지원하는 기능임

- 사용자 모드 (User mode)
  - 커널 모드의 메모리 접근 불가
  - 데이터 조작 불가
  - 커널 함수 호출 불가
  - 커널 모드에게 **시스템 콜**을 통해 동작을 요청

## 프로세스

- 프로그램 : 디스크 등에 저장되어 있는 실행 파일
- 프로세스 : 프로그램이 실행되어 메모리상에 존재하는 형태
  - 윈도우에서 작업관리자로 확인할 수 있는 형태

## 가상 주소 (Virtual Address)

- 실제 메모리상의 주소가 아닌 가상의 주소 사용
- 다른 주소 공간의 메모리는 접근할 수 없음
- 주소 공간을 각각 커널을 위한 공간과 사용자 공간이 나뉘어짐
  - 물론 각각의 공간은 각 모드에서 사용 가능
  - 커널 모드에서는 둘 다 접근 가능
- 사용자 공간을 프로세스마다 다르나 커널 공간은 프로세스마다 동일
- 커널 공간 : 0xffff_ffc0_0000_0000 ~ 0xffff_ffff_ffff_ffff
- 사용자 공간 : 0x0000_0000_0000_0000 ~ 0xffff_ffbf_ffff_ffff

## IPC (Inter-Process Communication)

- 프로세스끼리 상호작용을 하게 하는 것
- 종류
  - 커널이 값을 전달받아 대상 프로세스에게 복사하여 전달
  - 실제 메모리의 동일한 영역을 사용하는 주소공간을 각각 매핑하여 사용

## 스케줄링

- CPU의 자원을 관리하기 위해 도입
- *어떤 프로세스*를 *어떤 시점*에 *어떤 코어*에서 실행할지 결정하는 것
- **시분할 스케줄링**을 이용해 코어 개수보다 많은 개수의 프로세스가 실행되는 것이 가능
  - 타이머를 이용해 프로세스를 교대로 수행

### 문맥 전환

- 실행 중인 상태를 저장하고 앞으로 실행할 프로세스의 저장된 상태를 불러옴 (세션??)
- 문맥 전환 진행 과정 ;
  1. CPU 내에 저장된 데이터를 임시로 저장
  - 레지스터 이용
  - 소수점 연산 시 추가로 레지스터를 백업해야 함
  2. 실행할 프로세스의 주소 공간으로 바꾸기

## 인터럽트

- 하드웨어가 커널을 호출하는 것
  - 처리 결과나 예외 상황을 알려줄 때 사용
- 현재 어떤 모드인지에 상관없이 커널의 인터럽트 핸들러가 호출
- 인터럽트 덕분에 하드웨어를 기다리지 않고 그동안 다른 작업을 수행할 수 있음

## 디바이스 드라이버

- 하드웨어를 직접 제어하는 소프트웨어
- 인터럽트 처리, 하드웨어와의 통신 등을 담당
- 디바이스 드라이버가 다른 디바이스를 사용하기도 함
- 커널 모드에서 실행

## 가상 파일 시스템

- 파일을 다루는 시스템 콜 (open, read, write) 을 공통된 인터페이스로 제공
- 사용하는 입장에서는 파일 열듯이 다루면 된다
- 실제 파일 시스템과 실제 파일이 무엇인지 신경 안 써도 됨
- 커널에 새로운 기능을 추가할 때 시스템 콜 추가 없이 `file_operations` 만 정의하면 됨

- `/dev` : 디바이스 드라이버 제공
- `/proc` : 프로세스 정보 제공
- `/sys` : 하드웨어 정보 제공

---

# 시스템 콜 호출 추적하기

- `strace` : 프로세스가 어떤 시스템 콜을 호출하는지 추적하는 도구
  - `strace <command>` : 해당 명령어에서 실행되는 프로세스의 시스템 콜을 *화면*으로 출력
  - `-o <file> <command>` : 화면 대신 *파일*로 시스템 콜을 출력
  - `-o <file> -c <command>` : 시스템 콜의 개수를 세서 표로 출력
  - `-o <file> -p <PID>` : 실행 중인 프로세스에서 실행하는 시스템 콜을 출력

## 커널 Makefile 구조

- **Top-level Makefile** : 커널 소스 트리의 최상위 디렉토리에 위치한 Makefile. 환경 설정, 아키텍처 선택, 기본 설정 등을 다룬다.
- **Architecture-specific Makefile** : 특정 아키텍처에 맞는 설정과 규칙을 정의한다.
- **Kbuild** : 서브디렉토리와 그 하위 디렉토리에서 컴파일 규칙을 설정한다. 

- **obj-y** : 해당 변수는 커널 컴파일 시 어떤 오브젝트 파일 (`*.o`)을 포함할지 결정.
  - 디렉토리의 경우는 해당 디렉토리 내부 makefile의 obj-y 가 포함됨을 의미 

## Printk

- 커널 내에서 로그를 출력하고 싶을 때 사용
  - printf 함수와 사용이 동일
- 로그 레벨 : 어떤 메시지를 저장할지 정할 때 사용
  - 이미 정해져 있다

## SYSCALL_DEFINE 매크로

- 시스템 콜 함수를 정의하기 위한 매크로
- 시스템 콜이 가지는 인자의 수를 명시해줘야 함
- 매크로로만 시스템 콜을 정의할 수 있음
  - 함수 뿐만 아니라 관련 변수들도 같이 선언해야하기 때문
  - 아키텍처마다 시스템 콜의 형태가 다르기 때문에 매크로를 사용..

- 실제 strace를 사용하는 예시는 [strace로-ls가-사용하는-시스템-콜-알아보기](strace로-ls가-사용하는-시스템-콜-알아보기) 참조.

---

# 새로운 시스템 콜 추가하기

1. `kernel` 디렉토리 밑에 시스템 콜 관련 코드를 작성
2. `Makefile` 을 열어 `obj-y` 에 시스템 콜 관련 코드의 오브젝트 파일(`*.o`) 추가
3. 시스템 콜에 고유 번호를 추가하기 위해 `include/uapi/asm-generic/unistd.h`에 `__SYSCALL` 매크로를 이용해 추가
4. 커널을 다시 빌드하면 해당 커널에 시스템 콜이 추가됨! 신기하다 
5. 이제 프로그램을 하나 컴파일한 후 rootfs에 마운트 시켜야 한다.
  - 운영체제 부팅 시 포함되도록 한다는 것! 

## 시스템 콜을 사용하는 응용프로그램 만들기

- gcc를 쓰지 않고 툴체인을 이용해야 함

---

# GDB를 통한 디버깅

## GDB란?

- 프로그램을 실행하는 중간에 어떤 일이 일어나는지 보여주는 디버거의 일종
- 다양한 아키텍처를 디버깅하기 위해서는 gdb-multiarch 필요 (apt를 이용)

## GDB 명령어

- `start <인자>` : 프로그램을 주어진 인자값을 주고 실행
- `cont` : 프로그램 실행
- `list` : 현재 위치화 그 주변에 있는 코드를 10줄 가량 출력
- `backtrace` : 함수가 호출된 히스토리를 출력
- `info local` : 함수 내에 선언된 변수 출력
- `info args` : 현재 함수의 인자값 출력
- `print <식>` : 현재 시점에서 해당 수식이 실행될 때의 값 출력
- `step` : 코드의 한 줄 실행, 함수 호출이 있다면 함수 안으로 들어감
- `next` : 코드의 한 줄 실행, 함수 안으로 들어가지는 않음
- `finish` : 현재 함수가 리턴되는 지점까지 실행

### Breakpoint 명령어

- `break` : 해당 위치에 브레이크포인트 지정
- `info break` : 설정된 브레이크 포인트 출력
- `clear` : 해당 위치의 브로에크 포인트 제거
- `delete` : 모든 브레이크 포인트 제거

이제 `gdb-multiarch <program>` 을 이용해 디버깅을 시작하자!
+) 바이너리를 디버그 모드로 빌드하는 것도 잊으면 안 된다

---

# 커널 디버깅 맛보기

- `-s`, `-S` 옵션을 붙이면 디버그 모드로 실행 가능
  - `-s`는 gdb가 붙을 수 있도록 1234 포트를 열어준다.
  - `-S`는 QEMU가 시작하자마자 멈춰있게 만들어 브레이크포인트를 거는 시점을 마련해준다.
- 커널도 디버그 모드로 빌드해준다.
  - Kernel hacking -> Kernel debugging [x]
  - Kernel hacking -> Compile-time checks and compiler options -> Debugging Information : Rely 어쩌구
