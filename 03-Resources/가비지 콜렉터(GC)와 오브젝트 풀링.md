---
tags: []
---
게임을 쾌적하게 즐기기 위해서는 사용자의 컴퓨터 사양도 중요하지만, 개발자가 얼마나 게임을 최적화 하는가도 상당히 중요한 문제이다. 이에 따라 반반 같은 고사양 똥겜이 나올지, 뱀서같은 저사양 갓겜이 나올지 결정되는 것이다. 물론 개발자들은 저사양 갓겜을 만들고 싶겠지만...

유니티에서는 게임 최적화를 위해 *가비지 콜렉터*(*Garbage Collector*)와 *오브젝트 풀링*(*Object Pooling*)을 지원한다. 정확히는 '유니티가 지원한다'라는 말보다는 GC에서는 'C#이 지원한다', 오브젝트 풀링은 '유니티에서 구현 가능하다'라는 표현이 맞을 것이다. 실제로 구형 유니티에서는 오브젝트 풀링을 지원하지 않아 직접 구현했어야 하지만, 이제는 유니티에서 오브젝트 풀링을 자체적으로 지원한다.

## 가비지 콜렉터 (Garbage Collector)

**가비지 콜렉터**는 프로그래머가 따로 손댈 필요없이 언어의 런타임 환경에서 실행되는 메모리 관리 기술이다. 직접 메모리를 할당하고 해제해야 하는 C/C++ 과 같은 저급 언어와 다르게 이를 자동으로 실행해주며, 주로 고급 프로그래밍 언어에서 사용된다. 사용되지 않는 (참조되지 않는) 메모리를 자동으로 할당 해제해 메모리 사용을 최적화하고 메모리 누수를 방지한다. 

가비지 콜렉터는 각종 객체의 생성과 참조 상태를 추적해 필요없는 객체를 마킹한다. (객체 지향 프로그래밍 언어에 사용됨을 알 수 있다) 런타임 내내 실행되거나 메모리 누수가 발생하기 시작할 때 실행되는데, 이 때 위에서 마킹한 객체를 없앤다. 하지만 프로그램의 실행 속도가 느려지는 단점이 발생할 수 있기에 조심해야 한다.

## 오브젝트 풀링 

일반적인 프로그래밍에서는 오브젝트의 생성/삭제는 아주 많은 비용을 소모하지 않지만, 각 오브젝트마다 가지고 있는 속성과 메서드 변수들이 너무 많기 때문에 이를 일일이 생성하고 삭제하는데 많은 비용이 들게 된다. 따라서 오브젝트 풀에 미리 여러 개의 오브젝트들을 만들어 놓은 뒤, 필요할 때 꺼내서 사용하는 **오브젝트 풀링** 방식을 사용하기도 한다. 새로 오브젝트를 생성하지 않아 메모리 할당 및 초기화 과정을 건너뛸 수 있다. 내 기억에는 화면 내 총알 제한이 있었던 탄막 슈팅 게임에서 해당 방법을 사용했던 것 같다.

오브젝트 풀링의 기본 아이디어는 다음과 같다.
1. 오브젝트 풀 만들기 & 오브젝트의 수 정하기
2. 오브젝트 비활성화 
3. 필요 시 오브젝트 활성화 후 사용
4. 사용이 끝나면 비활성화

이제 아이디어에 따라 구현해보자.

먼저 오브젝트 풀을 만들고, 풀에 넣을 오브젝트와 오브젝트의 개수를 정한다. 오브젝트 풀은 [[선형 데이터 구조#큐|큐]]를 이용해 구현한다. 큐 내부에는 오브젝트를 채워넣되, 비활성화 상태로 채워넣는다.
```cpp
public GameObject prefab;
public int poolSize = 10;

private Queue<GameObject> objectPool;

void Start()
{
    objectPool = new Queue<GameObject>();

    for (int i = 0; i < poolSize; i++)
    {
        GameObject obj = Instantiate(prefab);
        obj.SetActive(false);
        objectPool.Enqueue(obj);
    }
}
```

오브젝트 사용시에는 풀에서 빼내야 하는데, 이 때 `Instantiate()`를 사용하는 것처럼 transform, rotation을 지정해줄 수도 있다. 풀에 오브젝트가 없는 경우에는 새로 만들어서 반환한다. 어차피 나중에 큐로 들어가니 상관없다.
```cpp
public GameObject GetObject(Vector3 position, Quaternion rotation)
{
	if (objectPool.count > 0)
	{
		GameObject obj = objectPool.Dequeue();
		obj.transform.position = position;
		obj.transform.rotation = rotation;
		obj.SetActive(true);
		return obj;
	}
	else
	{
		GameObject obj = Instantiate(prefab, position, rotation);
		return obj;
	}
}
```

사용하지 않는 친구는 다시 비활성화 시킨 뒤 큐에 넣는다.
```cpp
public void ReturnObject(GameObject obj)
{
	obj.SetActive(false);
	objectPool.Enqueue(obj);
}
```

- [?] 그러면 최적화를 위해서 화면 밖의 몬스터를 비활성화시키는 경우에서, 오브젝트 풀링을 사용하면 해당 몬스터를 다시 로드했을 때 다른 몬스터가 로드될 수도 있지 않나?
	- 그래서 상태를 아예 초기화시키거나 상태를 따로 저장하는 함수를 만든다.
- [?] 오브젝트 풀링에서 오브젝트의 개수를 지정한 뒤 풀에서의 개수가 모자라면 새로 만드는 방식은 결국 새로 만드는 방식이랑 다르지 않을까
	- 오히려 개수를 맞출 수 있어서 좋다고 보는데
	- 그렇다고 없으면 크래시 낼 수는 없잖아 