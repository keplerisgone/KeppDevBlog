# Summary

컴퓨터 과학의 기초인 진법, 비트와 바이트에 대해서 알아보자.
# Contents
## 진법

**진법**은 임의의 숫자 혹은 문자를 사용하여 숫자를 표현하는 체계이다. 

**10진법**(hexadecimal)은 우리가 흔히 사용하는 수 체계이다. 0~9까지의 수를 이용해 수를 나타낸다.

**2진법**은 0과 1로 수를 표현하는 체계로, 컴퓨터가 사용하는 진법이다. 2진법을 사용하는 수는 *0b*라는 접두어를 붙인다. 예를 들어 14를 2진수로 표현하면 0b1110이다.

**16진법**은 2진수를 좀 더 간편하고 효율적으로 표현하기 위해 만든 수 체계이다. 0~9까지의 숫자와 A~F까지의 알파벳을 이용해 수를 나타낸다. 16진수는 보통 *0x*라는 접두어가 붙는다. 예를 들어 12를 16진수로 나타내면 0xC이다.
## 비트와 바이트

컴퓨터에서 사용하는 데이터의 최소 단위(하나의 0 혹은 1)을 **비트**(bit), 8개의 비트로 구성된 것을 **바이트**(byte)라고 한다. 1바이트는 256가지의 수를 표현할 수 있다. 1바이트 단위의 숫자는 2진수 00000000~11111111 -> 16진수 00~FF -> 10진수 0~256 으로 나타낼 수 있다.

![](https://i.imgur.com/HRyG8uz.png)

> 16진수 한 자리는 2진수 네 자리로 변환할 수 있다.
### 최상위 비트(MSB), 최하위 비트(LSB)

여러 개의 비트로 구성된 데이터에서 가장 왼쪽에 있는 비트를 **최상위 비트**(Most Significant Bit), 가장 오른쪽에 있는 비트를 **최하위 비트**(Least Significant Bit)라고 한다. 아마도 가장 왼쪽의 비트가 크기에 중요한 영향을 끼쳐서 그런 것 같다.
### 부호 비트

<u>부호가 있는 데이터</u>의 경우, MSB는 부호의 의미를 가진다. 보통 1은 음수, 0은 양수라는 의미이다. 
## 바이트 오더링

**바이트 오더링**(byte ordering)이란 여러 바이트로 구성된 데이터를 메모리에 정렬하는 방식을 말한다. **빅 엔디안**과 **리틀 엔디안** 방식이 있다.

**빅 엔디안**(Big Endian)은 <u>가장 큰 바이트(왼쪽)부터</u> 메모리의 낮은 주소에 저장된다. 주로 네트워크 상에서 데이터를 전송할 때, SPARC CPU에서 빅 엔디안 방식을 사용한다.

![](https://i.imgur.com/uFAfh0a.png)

**리틀 엔디안**(Little Endian)은 <u>가장 작은(오른쪽) 바이트부터</u> 메모리의 낮은 주소에 저장된다. 대표적으로 인텔의 x86, x86-64 CPU에서 리틀 엔디안을 사용한다.

![](https://i.imgur.com/cCvVnRC.png)

바이트 오더링은 리버스 엔지니어링을 배울 때 필수적으로 고려해야 한다. *메모리에 어떻게 저장되어 있는지 알아야, 메모리의 데이터를 역으로 빼낼 수 있기 때문이다*. 사람들이 가장 많이 사용하는 x86 아키텍처는 **리틀 엔디안**을 사용한다. 다음과 같은 사항에 유의하자.
- 문자열을 메모리에 저장할 때는 리틀 엔디안을 고려하지 않고 문자열 순서대로 메모리에 저장한다.
- 그 외 데이터는 리틀 엔디안 방식으로 저장한다.

## 비트 연산

피연산자를 2진수로 변환하여 비트 단위로 연산하는 것을 **비트 연산이라고 한다**.
###### 논리 연산
- `x || y` : OR 연산
- `x && y` : AND 연산
- `!x` : NOT 연산
###### 비트 연산자 (비트 단위로 연산)
- `x | y` : OR 연산
- `x & y` : AND 연산
- `x ^ y` : XOR 연산
- `~x` : NOT 연산
###### 시프트 연산자
- `x << n` : 비트를 n만큼 왼쪽으로 이동
- `x >> n` : 비트를 n만큼 오른쪽으로 이동, 왼쪽 빈 칸은 MSB와 같은 값으로 - *산술 시프트*
- `x >>> n` : 비트를 n만큼 오른쪽으로 이동, 왼쪽 빈 칸은 모두 0 - *논리 시프트*
### 비트 연산 활용

- **비트 마스킹**(Bit Masking) : 특정 위치의 비트를 표시하거나 가리는 것, 1과의 AND 연산 활용
- **특정 비트/바이트 가져오기** : 시프트 연산, AND 연산을 이용해 특정 비트/바이트 가져오기
- **비교 및 암호화** : XOR 연산을 이용해 비교 및 암호화가 가능
- **시프트 연산을 이용한 곱셈과 나눗셈** : / 2^n, * 2^2가 가능
## 인코딩, 디코딩

**인코딩**(Encoding)은 데이터를 특정한 형식으로 변환하는 것, **디코딩**(decoding)은 인코딩된 데이터를 원래의 값으로 돌리는 것을 말한다. 암호화와는 다르게 표준 방식을 사용하므로 누구나 변환을 할 수 있다. 대표적인 인코딩 방식은 다음이 있다.
##### 아스키 코드
**아스키 코드**(ASCII)는 미국 표준 코드로, 각종 문자를 숫자로 변환해 놓은 것이다. 아스키 문자 하나는 1바이트 크기로, 7비트는 문자, 1비트는 오류 체크용이다. 
##### 유니코드
**유니코드**(Unicode)는 전 세계 모든 언어의 문자에 고유한 번호를 부여하는 *국제 표준*이다. 최대 32비트(4바이트)로 문자를 나타낸다. 처음 128개 문자는 아스키 코드와 동일하다. UTF-8, UTF-16, UTF-32 등 다양한 인코딩 방식이 있고, 뒤의 숫자가 비트를 의미한다.
##### URL 인코딩
URL은 특정 형식의 문자열만 허용한다. 따라서 허용되지 않는 문자를 `%` 기호 뒤에 숫자를 붙여 인코딩 한다. 대표적으로 ` `(공백) 문자는 `%20`으로 변환된다. 인코딩이 필요한 특수문자는 `:/?#[]@!$&'()*+,;=%공백`이 있다.
##### base64 인코딩
64개의 아스키 문자를 이용해 이진 데이터를 변환하는 인코딩 방식이다.
>  `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`

주로 텍스트만 허용되는 환경에서 다른 이진 데이터를 넣을 때 (HTML에 이미지를 넣을 때) 사용한다. 
방식은 다음과 같다.
1. 원본 이진 데이터를 비트 나열하고, 6비트씩 끊어서 묶는다. 6의 배수가 아닐 경우 뒤에 0을 추가하여 맞춘다.
2. 6비트 묶음을 수로 변환한 뒤, base64 테이블에서 해당하는 문자를 찾아 변환한다.
3. 총 글자 수가 4의 배수가 되도록 문자 = 를 추가한다. (*총 비트가 8의 배수가 되게 하기 위해서*)
# Reference

https://arc.net/l/quote/ijnhwxav