https://en.cppreference.com

## 1주차

> 이 문서는 C++과 리눅스를 이용하여 데이터 구조와 알고리즘을 배우는 과목에 대한 내용입니다. 트리, 해시, 그래프 등의 자료 구조를 배우며, 숙제는 월요일 11시까지 제출하며 실행 여부와 최적화 정도를 기준으로 채점됩니다.

![[Media/00_Intro 2.pdf|00_Intro 2.pdf]]

![[Media/01_Linux_basic 2.pdf|01_Linux_basic 2.pdf]]

![[Media/01_Linux_command 2.pdf|01_Linux_command 2.pdf]]

- 서버 접속으로 수업 진행
- c++
- 리눅스 - 기본적 프로그래밍 - 데이터 구조 및 알고리즘을 배웁니다
- 트리라는 자료 구조, 해시, 그래프 등에 대해서 배웁니다.
    
    - 트리는 데이터 구조 중 하나로, 계층적으로 구성된 데이터를 표현함으로써 검색 및 정렬을 용이하게 합니다. 해시는 키와 값이 쌍을 이루는 자료 구조로, 빠른 검색과 삽입이 가능합니다. 그래프는 노드와 엣지로 구성된 자료 구조로, 여러 개의 노드들이 서로 연결되어 있는 구조를 나타냅니다.
    
      
    
- 숙제는 월요일 11시까지 입니다
- 채점 기준은 실행 여부, 최적화 정도입니다

### How are server & Client working?

- 엘렐레
- “서버”가 클라이언트의 커맨드를 실행

---

### Compile

- 사람이 짠 코드 (Programing Language) 를 기계가 알아들을 수 있게 (Machine Language) 변환하는 과정
- C언어의 경우) .c 파일 (소스코드) + 헤더 파일(.h) ⇒ .i 소스코드 (Preprocessing)
    - .i 소스 코드 ⇒ .s 파일(어셈블리어)로 컴파일 (여기서도 함수의 정의는 없음)
    - .s 소스 코드 ⇒ .o 오브젝트 코드 어셈블 (진짜 기계 언어로 변환)
    - -lc 로 c 라이브러리를 링크 (각종 함수들의 정의를 링크시킴)

![[Media/Untitled 24.png|Untitled 24.png]]

---

### Makefile

- 근데 하나하나 전부 컴파일 할 수는 없다
- 그래서 만들어 진 것이 바로 Makefile 기능입니다.
- 컴파일을 미리 정해진 대로 빠르게 수행할 수 있게 합니다.
- Makefile 을 실행하는 법은 `make` 명령어를 이용하는 것입니다.
    
    ```Makefile
    make : 일단 Makefile 내부의 것들을 모조리 만듭니다.
    make -f filename : 파일 명이 Makefile 혹은 makefile이 아닐 때 사용합니다.
    make target_name : Makefile 내부의 것들 중 하나만 만들 때 씁니다.
    ```
    
- Makefile 내부는 이렇게 작성합니다.
    
    ```Makefile
    target : prerequisites
    				commands
    > ex
    testprog : test.o prog.o
    				gcc test.o prog.o -lc -o testProg
    test.o : test.c common.h
    				gcc -c test.c
    prog.o : prog.c common.h
    				gcc -c prog.c
    ```
    
    - 재료를 주면 전처리, 어셈블, 컴파일한 파일을 출력해주는 것 같습니다.
- 변수를 사용가능합니다. 변수를 위에 선언하고, $()안에 변수 이름을 넣어 사용가능합니다. 
    
    ```Makefile
    CC = gcc
    OBJS = test.o prog.o
    HDRS = common.h
    
    testprog : $(OBJS)
    				$(CC) $(OBJS) -lc -o testprog
    test.o : test.c
    				$(CC) -c test.c
    prog.o : prog.c 
    				$(CC) -c prog.c
    $(OBJS) : $(HDRS)
    ```
    
    - 이제 변수에 .o 파일과 .h 파일을 추가하는 것으로 좀 더 쉽게 컴파일할 수 있습니다.
    - 근데 .o파일 컴파일을 일일이 추가하는 건 어려워 보이네요… 자동으로 추가할 방법이 없을까요?
- 터미널에서와 마찬가지로 특정 확장자를 불러오는 것이 가능합니다!
    
    ```Makefile
    CC = gcc
    OBJS = test.o prog.o
    HDRS = common.h
    
    testprog : $(OBJS)
    				$(CC) $(OBJS) -lc -o testprog
    %.o : %.c 
    				$(CC) -c $<
    $(OBJS) : $(HDRS)
    ```
    
    - 모든 .c 파일을 .o 파일로 컴파일 할 수 있게 되었습니다!
    - Special Variables 가 사용되었습니다.
        - $< : Prerequisites 의 이름
        - $@ : target 의 이름
        - $^ : Prerequisites 전체의 이름
        - $? : 타겟보다 최신인 Prerequisites 의 이름
    - 하지만 아직도 .o 를 일일히 추가해야 한다는 단점이 있습니다.
- Shell 명령어를 이용해봅시다.
    
    ```Makefile
    CC=gcc
    SRCS = $(shell ls *.c)
    OBJS = $(SRCS:.c=.o)
    HDRS = $(shell ls *.h)
    
    testProg : $(OBJS)
    			$(CC) $(OBJS) -lc -o testProg
    %.o : %.c
    			$(CC) -c $<
    $(OBJS) : $(HDRS)
    ```
    
    - 이러면 자동으로 ls 내부에 있는 .c 파일을 변수에 추가하고, .o 파일로 어셈블 합니다.
- 쓰면 편한 Target들
    - all : 이 파일에서의 top level target을 설정합니다.
    - clean : rm 명령어를 입력하면 다 지워줍니다.
    - print : 수정된 것들을 print합니다.
    - if 문도 쓸 순 있는데… 쓸까

## 2주차

![[Media/02_CPP_Types 2.pdf|02_CPP_Types 2.pdf]]

![[Media/03_CPP_Flow 2.pdf|03_CPP_Flow 2.pdf]]

## Minimal C++ Program

- main() + input + output(return) → type + comments
- Hello World
    
    ```C++
    \#include <iostream>
    
    int main(){
    	 std::cout << "Hello, World!\n";
    }
    ```
    
    - `std::` : namespace, 함수를 찾는 곳 중에 하나
        - `std::cout` : standard 안의 cout
    - `using namesplce **` : ** namespace를 기본적으로 사용합니다.

---

## CPP Data Types

![[Media/Untitled 1 16.png|Untitled 1 16.png]]

+) 기계가 작동하는 법

- Boolean
    - 참과 거짓
- Character
    - 글자 하나
    - 8개의 bit가 1byte
- Integer
    - 4bytes
- Floating
    - 8byte - double, 4byte - float

### Types

- built-in types / user-defined types
    - string은 빌트인이 아니에요
- auto 로 간단하게 타입을 지정할 수 있다
- const 는 constant로 변환을 못하는 상수이다

### Declaration and Assginment

- Variable : 값의 이름
- 중요 cin에서 띄어쓰기는 날린단다
    - 그래서 cin << ** << ** 한다음에 나중에 변수로 정의함 +

---

+) 서버에서 파일 업로드 / 다운받는 방법

```Shell
scp -P20202 (file) y2022142137@class.corelab.or.kr:~/directory

scp -P20202 (id):~/directory (directory)
```

---

## CPP Flow

- Flow chart
    
    - 순서도, 흐름도
    
    ![[Media/Untitled 2 16.png|Untitled 2 16.png]]
    

### Conditionals

- If 
    
    ```C++
    if (boolean expression)
    	statement A
    
    else
    	statement B
    ```
    
- Switch
    
    ```C++
    switch (value){
    	case A : statement 1;
    		break;
    	case B : statement 2;
    		break;
    	case C : statement 3;
    		break;
    	default : statement 4;
    }
    ```
    
    - break 없으면 슬퍼짐

### Loops

- While loop
    
    ```C++
    while (boolean expression){
    	statement 1;
    	statement 2;
    }
    ```
    
    - endl = \n
    - sqrt의 계산법
        - n = t * t 인것을 이용해, n / t 의 평균값을 구하는 방식으로 계산한다.
- Do While loop
    
    - 일단 한번 하고 반복문을 실행한다
    
    ```C++
    do {
    	statement1;
    	statement2;
    } while (boolean expression)
    ```
    
- For loop
    
    - 초기화 부분 + 증가하는 부분 + 실행 부분
    
    ```C++
    for (init; boolean exp ; increment) {
    	statement1;
    	statement2;
    }
    ```
    
- Error Handling
    - Error
        - Syntax : 컴파일러가 투덜거림, 문법을 잘못 씀
        - Semantic : 문법적 오류는 없는데 예상과 결과가 다름
        - Performance : 효율적이지가 않음
            - ex) * << + << shift
    - Assertion
        - 이건 뭐람
    - Exception
        - try(), catch()
        - (신기) cerr

## 3주차

![[Media/04_CPP_Memory 2.pdf|04_CPP_Memory 2.pdf]]

![[Media/05_CPP_Modularity 2.pdf|05_CPP_Modularity 2.pdf]]

- 슬프게도 숙제가 있음 up & down

## CPP Memory

### Memory

- CPU (Addresses) ↔ Memory (Code/Data) / 서로 주고 받습니다.
- 주소에다가 이름 지어준거 = 변수
    
    - 변수를 선언하면 주소와 변수를 매칭시킨 뒤 값을 줍니다.
    
    - 파이썬은 값에 메모리를 할당한 뒤 값을 변수에 연결시키는 방식이라, 값을 바꾸면 메모리도 바뀐다
- 각종 변수의 주소는 프로그램을 실행할 때마다 바뀝니다.

- 32bit, 64bit의 차이?
    - 메모리 공간의 차이입니다. 그래서 각종 변수가 할당받는 바이트의 수가 달라집니다.
    - 예를 들어, `sizeof(void*)` 의 값은 32bit에서 4bytes, 64bit에서 8bytes입니다. 만약 64bit의 값을 32bit로 불러왔을 경우 바이트가 잘려 오류가 발생할 수 있습니다.

### Pointer

- 왜 써요?
    - 컴퓨터에게 변수 여러 개 바꾸는 일을 떠넘기기 위해서
    - 생각보다 함수 안에서 main() 함수의 변수를 바꿔야할 경우가 많다
- 뭐에요?
    - 어떤 변수의 주소를 할당받는 변수의 종류입니다.
- Declaration
    
    ```C++
    // type * name;
    int *Pvar;
    ```
    
    - 변수의 주소를 포인터에 저장하고 포인터의 주소를 또 변수에 저장하고 그럼 또 그 변수의 주소를 다른 변수에 저장하고
- Address-of operator
    
    ```C++
    // type * name;
    int var = 10;
    int *Pvar = &var;
    ```
    
    - &(name of variable) : variable 의 주소를 불러오는 연산자입니다.
    
    - 그럼 변수에 원하는 메모리를 할당시킬 수 있나요
        
        ⇒ 예, 하지만 보장은 못합니다
        
    - type system
        - 언어 내부에서 각종 타입에 대한 처리를 어떻게 할 것인지 정의되어 있는 겁니다.
        - C, C++ 에서 int 는 4bytes, char는 1byte, short는 2bytes, long은 8bytes 를 할당하도록 설정되어 있습니다.
- Deference operator
    
    ```C++
    cout << pVar;  \\ 0x1564 = 주소값
    cout << *pVar;  \\ 7 = 해당 주소값의 값
    cout << &pVar;  \\ 0x1996 = 포인터 변수의 주소
    ```
    
    - *(pointer) : pointer 가 가리키는 주소의 값을 출력합니다.
    
    - int **에다가 *를 붙여서 출력시키면 당연히 포인터 변수를 출력하겠지?????????
        - 맞워요
        - a = *pa = **ppa ← pa = &a = *ppa ← ppa = &pa
        - 근데 이상하게 &&는 안되더라
- Double pointer
    
    - 변수를 가리키는 포인터를 가리키는 포인터
    
    ```C++
    int a = 5;
    int *pa = &a;
    int **ppa = &pa;
    ```
    
- void pointer
    - 타입이 없는 포인터, 자동으로 매칭시켜 주지는 않음
    - 가리키는 변수의 값을 불러올 떄는 형변환 필요
    - void_pointer.cpp
    - char 변수 ++ 했을 때 연산 어케 됨
- Null Pointer
    - 그냥 선언하는 거랑 뭐가 다른가?
        - 더미값을 지정하지 않고, 그냥 ‘없는 값’이 됩니다.

### Reference

- 탄생 배경 : 포인터를 대체하기 위해 도입되었다. 주소값을 직접 참조하는게 아닌 변수에 별명을 달아 사용하는 것.
- 변수 이름2
- 항상 초기화 해야 한다
    
    ```C++
    int &k = 5;
    int &k; \\ 오류 발생
    ```
    
- 그럼 내부적으로 처리할 때 아예 동일하게 처리되냐 아니면……
    - 동일하게 처리됩니다. 아예 주소에 레퍼런스를 할당하기 때문에, 무슨 변수의 레퍼런스인가 참고하는 과정은 없습니다.

- 별명을 불러오는 연산자는 없나요
    - 없대요
- Reference 는 함수 내부에서만 쓰고 사라짐???????????
    - 사라지지만 값은 바꿀 수 있네요

### Arrays

- 같은 타입 변수들의 모임
- Pointers and Arrays
    - A = &A[0] \\ 주소인 것은 맞지만 변수는 아니기 때문에 다른 곳에 할당은 불가능
- Pointer Arithmetics
    - 해당 type 의 byte 수 만큼 띄어서 저장하는 편
    - pChar++ ⇒ pChar + 1 * sizeof(char)
    - pShort++ ⇒ pShort + 1 *sizeof(short)

### Dynamic Allocation

```Python
int * ptr = new int; // 포인터에 주소를 리턴
// (void*) (포인터변수명) = new type;

delete ptr; // 메모리 할당 해제
```

- Dynamic Allocation = 동적할당
    - 보통 메모리를 많이 할당해야 할 때 사용합니다.
    - 아래에서 볼 수 있지만, 보통 사용하는 local variable은 Stack에 저장되는데, Stack의 크기는 한정되어 있기 때문에 크기가 큰 변수나 함수, 배열을 담기에 부적합합니다.
    - 길이를 모르는 배열을 사용할 때도 동적 할당을 사용합니다.
- new : Heap에 메모리 자리를 내어줍니다.
    - 주소를 리턴하는 연산자이기에, 포인터 변수가 필요하다
- delete : 퇴실합니다.
    - 반드시 해주어야 메모리 누수가 일어나지 않는다.

### x86-64 Linux Memory Layout

- Stack : local variables, Runtime stack (8MB) - 작다
- Heap : Dynamically allocated as needed, malloc(), calloc(), new()
- Data : global variables, static, string constants
- Text / Shared Libraries : machine instructions
- 메모리의 구성

### Pointers and const

```Python
int x;
int * p1 = &x; // non-const pointer to non-const int
const int * p2 = &x; // non-const pointer to const int
int const * p3 = &x; // non- const pointer to const int
int * const p3 = &x; // const pointer to non-const int
const int * cinst p5 = &x; // const pointer to const int
```

### Function Pointers

- 함수안에함수안에함수안에함수안에함수안에함수
- 함수의 주소를 저장하는 변수

```Python
int addition(int a, int b){return (a+b);}
// addition에 함수의 주소를 저장

int subtraction(int a, int b){return (a-b);}

int operation(int a, int b, int(*pF)(int,int)){ // 함수 포인터 (*pF) 사용,
	int g = (*pF)(x,y); // (*pF) = 함수 포인터 pF가 가리키는 함수
	return g;
}

int main(){
	int m,n;
	int (*minus)(int,int) = subtraction; // minus에 subtraction 할당

	m = operation(7,5,addition);
	n = operation(20, m, minus);
}
```

- 이렇게 사용

## 사라져버린 4주차

## 5주차

## CP 05 : Modularity

### Modularity

- Distinguishes between the interface (declaration) to a part and its implementation (definitions)
- Declaration
- Definition

### Funtion

- Declaration
- Definition - body
- 작게작게 만들자 - 재사용성이 높아짐
    - 버그도 잘 찾아
- Overloading
    - 이름은 같은데 받는 arguments가 다름
    - 다른 함수

### Overload

- asdaf;hawieufh;wigu;
- type으로도 구분이 가능한ㄷ

### Template

- 똑같은 일을 하는 다른 타입의 무언가들을 합치기

```C++
// 쓰는 법
template <template-parameters>
function-declaration

// 쓴다
function_name <template-argumant> (function-arguments)

// 예시는 굳이 하지 않겠다
```

- ‘알아서 해줘’ 가 된다
- 함수 앞에 하나씩 반드시 붙어야 합니다
- 실행시간이 더 빠르대…. 어?
    - 함수는 애초에 만들어졌을 때 메모리가 만들어짐 → 나중에 함수를 호출했을 때 들어감 근데 템플릿 같은 경우는 왜지???????????? 아하 컴파일 과정에서 그냥 들어가기 때문에 미세하게 빠르다.

### Scope

- 변수가 영향을 끼치는 범위
- Global scope
- Class scope
- Local scope = block scope
- Statement scope
- 변수 이름은 scope 마다 하나 (함수 안에서, main안에서 a를 동시에 선언할 수 있는 이유)

![[Media/Untitled 3 15.png|Untitled 3 15.png]]

### 추가

- 정적 변수 = static variables
    - 함수 내부에서 선언되고, 함수가 끝나도 사라지지 않는 변수

## 6주차

### Namespace

- 같은 이름의 함수가 있을 수도 있음
- 이런 함수들을 나눠주는 역할
    - ex) a::sum, b::sum : a와 b scope의 sum 함수들
- 쓰는 법
    
    ```C++
    namespace namespace_id {
    	int function1(){}
    	int a, b;
    }
    
    namespace_id::function1 // 처럼 사용
    ```
    
- using namespace <namespace_id>
    - :: 쓰기 귀찮아서 만든 거

### Structures

- 다른 타입들의 변수를 담고 있는 뭔가 뭔가

```C++
struct student {
	int age;
	char name[10];
};

student A;
A.age = 21;
```

- structure에 대한 pointer도 만들 수 있다
    - 근데 (*pV).sz 같은 걸 쓰기 귀찮으니까  
        pV→sz를 쓴다  
        

### Classes

- structure처럼 뭔가를 많이 담고 있는 무언가
- 근데 변수뿐만이 아니라 함수도 담을 수 있다
- 접근 권한을 데이터/함수 마다 다르게 줄 수 있구나
    - private :
    - protected :
    - public :
- ::를 붙여서 해당 member가 어느 클래스에 있는지 알려준다
    - 함수를 정의할 때만 사용하나
- self를 안 쓴다
- operator overloading
    - 그냥 함수를 작성하는 것보다 얼마나 편리한가요
    - member, non-member function으로 나눠집니다
- template를 사용가능합니다.
- Construct & Deconstruct 의 방법을 참고
    - Deconstruct는 함수가 끝날 때 일괄적으로… 일어나나…?

## CPP 06 : Input/Output

### std Input

### std Error

### File I/O

- file stream classes

### File Stream Positioning

- 간격??? - 1byte
- 어…! 음… 응…! 그래.

## 7주차

## CPP 07 : OOP

= 객체 지향 프로그래밍

- encapsulation
    - 사용자에게 감출 ㅜㅅ 있는가 없는가
    - friend class - 일방적이다
- inheritance
    - 상속 - 있는 걸로 더 까리한거 만들기
- polymorphism

## CPP 08 : Performance

### Sorting example

- selection sorting - find minimum val, find next minimum val…

### Merge sorting

- divide list in n-sub lists

### Performance Analysis

- memory / running time
- empirical / theoretical
    - empirical : calculation based on real result(time)
    - theoretical : calculation based on pseudocode
        - space complexity : memory
        - time complexity : time
- Runnnig time analysis :
    - when N is large, the maximum term = a power law

### Growth functions

- Constant
    - +
    - classic operator
- Linear
    - *
    - for
- Logarithmic
    - while
- Quadratic
    - for in for
- Cubic
    - for in for in for
- exponential

### Asymptotic

### Big O / Omega / Theta

rjrltjsms djtpaqmffldj qodnrpTwl

## 8주차

## 09 : Array Vector

### Array

- fixed-size container
    - there is a limitation
- same time to update / remove / add

### Vector

- can be dynamically allocated
- `std::vector<Customer> vCustomers;`
- push_back / pop_back - back에 집착하는 편
- insert - 중간에 null 있으면 어떡함
- erase - removes a element and range of vector
- how does it resize - copy newsize array (오래걸리지 않나)
    - Incremental - increase by a constant
        - $T(n) = O(n^2)$﻿ : the total time of an add operation (resize time)
        - Amortized time of and add operation : $O(n)$﻿ - a one components
    - doubling - double the size
        - $T(n) = O(n)$﻿ :
        - $O(1)$﻿

## 10 : Linked List

- vectors are tooooo slow → use pointers!

### Linked List

- node = its date + link to other node (adress)
- but it’s also slow… like python’s list
    - I want to access index 10! → 1..2..3.4..5……10!

### Singly Linked List

- Head - first adress & data
- Tail - connected with last pointer
- Time complexity
    - insert : $O(1)$﻿ - linked with tail
        - constant time value
    - remove : $O(n)$﻿ - HEAD node finds (n-1) node
- 왜 안 써요 - 단방향이라서요

### Doubly Linked List

- each node has prev, next links and data
- Time complexity : $O(1)$﻿ for add, removal
- used in tree, graph, dynamically allocation

## 11. Stack

### Stack

- LIFO scheme
- push(), pop(), empty(), size(), peek()

아주그냥 라이브러리도 주고 클래스도 주고 선녀다선녀

그거 아십니까

‘bob 2023-04-31 cheese 5’랑

‘bob 2023-05-01 cake 7’ 은 비교 연산자가 먹힌다는 사실(숫자랑 알파벳 순으로 분류해줍니다)

GPT가 그랬음 난 모름

  

4번째 숙제ㅋㅋ

NP P 문제 (예습중)

TSP