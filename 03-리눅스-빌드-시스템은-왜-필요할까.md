# 리눅스 개발 환경 이해하기

- **빌드** (build) : 소스 코드를 실행할 수 있는 바이너리로 변환하는 과정
- **호스트** (host) : 빌드가 진행되는 환경
- **타겟** (target) : 빌드가 된 바이너리가 동작할 환경
  - 타겟에 따라 다른 바이너리 파일이 필요하다.

## 툴체인

- 원하는 타겟에 맞춰서 빌드를 해주는 개발 도구의 모음
- **컴파일러** (Complier) : 소스코드를 기계어로 번역 -> Object File
- **헤더 및 라이브러리** (Header, Library) : 기본 함수 모음
  - SDK?? 형태로 많이 배포됨
- **링커** (Linker) : 기계어와 라이브러리를 모아 하나의 바이너리 파일을 만듦.

- 가장 자주 사용하는 **gcc**(컴파일러) + **ld**(링커)

- 컴파일 명령어 + 링크 명령어
- 그리고 각각의 에러가 왜 일어나는지

## C 런타임

- 우선 `gcc -c *.c` 로 c 파일을 오브젝트 파일(.o)로 변환
- 링킹을 하기 위해서 `ld *.o`를 실행하지만 에러가 난다

  - 이는 라이브러리와 C Runtime 목적파일이 없기 때문에 발생한다!

- CRT 목적파일은 운영체제마다 다른 초기화 방식을 적용 및 main 함수를 호출하는 역할을 한다.

## 라이브러리

- 개발자가 직접 작성하지 않은 함수는 모두 라이브러리를 참조하는 것
- C의 경우 -l\* 옵션으로 라이브러리 지정 가능

  - 라이브러리의 이름에서 lib -> -l로 바꾸어 지정할 수 있다.
  - libc : 기본 C 라이브러리
  - libm : 수학 관련 라이브러리, math.h
  - libz : 압축 관련 라이브러리, zlib.h
  - libpthread : 스레드 관련 라이브러리, pthread.h
  - libstdc++ : C++ 기본 라이브러리

- 하지만 그대로 파일을 실행할 경우 오류 발생

  - 이는 실행 파일이 참조하는 다른 파일을 지정해주지 않아 발생
  - 의존성은 `ldd` 명령어를 이용해 볼 수 있다.

- LD 라이브러리는 동적 라이브러리(실행 중 갑자기 필요한 것)를 load하는 라이브러리이다.
- 옵션으로 `dynamic-linker`를 지정하면 된다.

- 사실 gcc로 링킹까지 가능 -> 근데 왜 컴파일과 링킹을 나누어 놓았을까?

## 점진적 빌드 (Incremental build)

- 점진적 빌드는 개발자가 수정한 부분과 의존성이 있는 부분만 컴파일하는 것을 말한다.
- 거대한 프로그램의 경우 한꺼번에 컴파일하는데 오래걸리기 때문
- 빌드 시스템을 이용해 가능!

## 빌드 시스템

- 의존성을 파악하지 않고도 점진적 빌드가 가능하게 한다.
- 수정한 부분과 의존성이 있는 부분을 분석
- 복잡한 컴파일 및 링킹 명령어를 다루지 않게 도와줌

- 종류
  - Makeflie : 가장 많이 쓰이는 빌드 시스템, 학부에서 배웠는데 기억이 안 난다.
  - CMake : CMakeLists.txt 로 작성하며, Makeflie로 번역되어 사용된다.
  - Ninja : 속도를 향상시키기 위한 빌드 시스템

### Makefile의 구성

- 타겟 : 생성하고자 하는 것
  - 맨 앞에 작성, `:` 를 이용해 의존성과 구분
  - 실제 파일 이름이나 간단한 이름 (.PHONY)으로 지정
- 의존성 : 필요한 것
  - 콜론 뒤에 여러 개 나열, `,`로 구분
  - 실제 파일 이름이나 타겟을 작성
- 명령어 : 해야 하는 것
  - 타겟 + 의존성의 다음 줄에 탭으로 들여쓰기 하여 작성
  - 한 줄이 하나의 프로세스?
  - Shell Script로 동작

```
.PHONY : Target2

Target1 : Dependency1, Dependency2
	Command1
	Command2

Target2 : Dependency3, Target1
	Command3
```

makefile 실행하는 법 : make <원하는 타겟> -j<코어 개수>

여기서 원하는 타겟은 Makefile 내부에 지정된 타겟들이 될 수 있으며, 지정하지 않으면 처음 명시된 타겟(주로 .PHONY)가 된다.

- Makefile에서는 변수를 사용할 수 있다.
  - <변수 이름> := <값> : 변수에 값을 할당
  - <변수 이름> += <값> : 변수에 값을 추가
  - <변수 이름> ?= <값> : 변수가 선언되어 있지 않으면 값을 할당
  - 사용은 `$(<변수이름>)` 으로!
- 기본 변수
  - `$@` : 현재 타겟 이름
  - `$<` : 의존성 각각 하나
  - `$^` : 의존성 전체

---

# 커널

- 운영체제의 핵심적인 부분 (프로세스, 파일시스템, 드라이버)
  - 윈도우 커널 : c:\windows\system32\ntoskrnl.exe
  - 리눅스 커널 : /boot/vmlinuz
- 사용자가 직접 실행하거나 조작 불가
- 부트로더 : 운영체제를 로드해서 실행하는 부분

## 루트파일시스템 : Rootfs

- 운영체제에서 필요한 앱이나 라이브러리와 같은 기본 파일

  - `/`에 담기는 기본적인 파일들

- Init 프로세스는 리눅스 커널이 가장 처음 띄우는 프로세스
- 루트 파일 시스템에 포함됨
  - systemd : 가장 유명한 init
    - `/etc/systemd/` 아래의 서비스 설정파일을 읽어 서비스를 실행
  - android init : 안드로이드에서 사용
  - systemV : 가장 오래된 init
  - shell : 서비스 없이 shell만 실행할 수도 있음

## Buildroot

- 맞춤형 루트파일시스템을 만들어 주는 프로젝트
  - 빌드 시스템의 일종이다?
- 빌드 시스템은 Makefile로 구성되어 있음
- 필요한 요소들을 자동으로 다운해줌 (Makefile이다)
  - 이걸 안 쓰면 알아서 수동으로 전부 다운해야 함
- [오픈 소스니까 코드를 한 번 살펴보는 것도 좋아~](https://github.com/buildroot/buildroot)
- Git을 이용해 다운받자.

```
git clone git://git.buildroot.net/buildroot
```

## Makefile 설정

- 위에서 말했듯 buildroot의 빌드 시스템은 Makefile로 이루어져 있다.
- 빌드 시스템은 .config를 이용해 설정 가능

  - 커널과 빌드 루트에 한해서..

- `make \*config` : .config 생성을 도와주는 도구
  - `config` : 모든 옵션에 대하여 값을 입력해 설정
  - `*defconfig` : 미리 설정되어 있는 값을 사용, 파일 이름은 내부에 존재
  - `oldconfig` : 버전이 변경되었을 때 파일을 현재 버전에 맞게 수정
    - `olddefconfig`도 사용 가능
  - `menuconfig` : 텍스트 기반 GUI 형 설정
  - `xconfig` : 진짜 GUI 형 설정

1. defconfig 를 이용해 설정을 한다. 파일 경로는 `buildroot/configs/`
2. `ncurse` 라이브러리를 다운받은 후, `make menuconfig` 로 설정 진행
3. 설정을 진행한 후, `make -j<core>` 을 하면 `rootfs.tar`가 생성됨
4. 루트파일시스템 준비 완료!

# 리눅스 커널 빌드하기

## 커널 다운로드

- [https://kernel.org/](https://kernel.org/) 로 가서 직접 다운받거나 git 으로 다운받으면 된다.

## 커널 빌드 환경 세팅

- 필수 라이브러리 설치
```
sudo apt install libelf-dev libssl-dev bison flex
```

- 툴체인 설치

```
wget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
tar xvf gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
```

빌드 루트에서는 안에 이미 toolchain이 있기 때문에 필요가 없었다.

## 커널 설정하기 

- `defconfig`들 이용하여 미리 설정된 값을 적용
- QEMU를 사용하는 경우 `<Buildroot dir>/board/qemu/aarch64-virt/linux.config`에 존재하는 config를 커널에 복사
- 커널의 config 설정은 `/linux/arch/arm64/configs/qemu_defconfig`에 존재
- `ARCH=arm64 make qemu_defconfig` 로 설정 빌드, ARCH는 아키텍처 지정

## 커널 빌드하기

```
ARCH=arm64 CROSS_COMPILE=<toolchain dir>/bin/aarch64-none-linux-gnu- make -j<core>
```

으로 커널을 빌드 가능, Image를 생성한다. 
